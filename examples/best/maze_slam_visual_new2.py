import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import time
import random
import json
from collections import deque
import heapq

class MazeEnvironment:
    """Ëø∑ÂÆ´ÁéØÂ¢ÉÁ±ªÔºàÁªßÊâøÂéüÁâàÂäüËÉΩÔºâ"""
    
    def __init__(self, map_file="BreezySLAM-master/examples/map1.json"):
        self.size = None
        self.display_size = 18
        self.walls = []
        self.invisible_walls = []
        self.start_pos = None
        self.exits = []
        
        # ÂÖ•Âè£ÂíåÂá∫Âè£Ê£ÄÊµãÁä∂ÊÄÅ
        self.entrance_detected = False
        self.entrance_opening = None
        self.exit_detected = False
        self.exit_position = None
        self.discovered_exits = []  # Âä®ÊÄÅÂèëÁé∞ÁöÑÂá∫Âè£ÂàóË°®
        self.reached_exit_positions = []  # ËÆ∞ÂΩïÊú∫Âô®‰∫∫Âà∞ËææÂá∫Âè£Êó∂ÁöÑÁ°ÆÂàá‰ΩçÁΩÆ
        
        self.parse_maze_file(map_file)
        
    def parse_maze_file(self, map_file):
        """Ëß£ÊûêËø∑ÂÆ´Êñá‰ª∂"""
        try:
            with open(map_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            if map_file.endswith('.json') or content.strip().startswith('{'):
                self._parse_json_format(content, map_file)
            else:
                self._parse_txt_format(content, map_file)
            
            self.calculate_maze_size()
            # ÁßªÈô§È¢ÑÂÖàÂá∫Âè£ÂàÜÊûê - ÂÆûÁé∞ÁúüÊ≠£ÁöÑSLAMÊé¢Á¥¢Ê®°Âºè
            # self.find_exits()  # Ê≥®ÈáäÊéâÔºåËÆ©Êú∫Âô®‰∫∫ÈÄöËøáÊé¢Á¥¢ÂèëÁé∞Âá∫Âè£
            
            if self.start_pos is None:
                self.start_pos = (0.0, 1.0)
                
            # Ê†πÊçÆËµ∑ÁÇπÊòØÂê¶Âú®ËæπÁïå‰∏äÔºåËá™Âä®Ë∞ÉÊï¥Ëµ∑ÁÇπÂπ∂Ê∑ªÂä†ËôöÊãüÂ¢ô
            self._setup_virtual_entrance()
            
            print(f"Successfully loaded maze file: {map_file}")
            print(f"Found {len(self.walls)} walls")
            print(f"Start position: {self.start_pos}")
            print(f"üîç True SLAM mode: Robot will discover exits through exploration")
            
        except Exception as e:
            print(f"Error loading {map_file}: {e}")
            self.create_default_maze()
    
    def _parse_json_format(self, content, map_file):
        """Ëß£ÊûêJSONÊ†ºÂºè"""
        data = json.loads(content)
        
        if 'segments' in data:
            for segment in data['segments']:
                start = segment['start']
                end = segment['end']
                x1, y1 = float(start[0]), float(start[1])
                x2, y2 = float(end[0]), float(end[1])
                self.walls.append(((x1, y1), (x2, y2)))
        
        if 'start_point' in data:
            start_point = data['start_point']
            x, y = float(start_point[0]), float(start_point[1])
            self.start_pos = (x, y)
    
    def _parse_txt_format(self, content, map_file):
        """Ëß£ÊûêTXTÊ†ºÂºè"""
        lines = content.splitlines()
        
        for line in lines:
            line = line.strip()
            if line.startswith('#') or not line:
                continue
            
            if '->' in line:
                line_content = line.split('#')[0].strip()
                parts = line_content.split('->')
                start = parts[0].strip('()')
                end = parts[1].strip('()')
                
                x1, y1 = map(float, start.split(','))
                x2, y2 = map(float, end.split(','))
                self.walls.append(((x1, y1), (x2, y2)))
                
            elif line.startswith('start:'):
                line_content = line.split('#')[0].strip()
                pos_str = line_content.split(':')[1].strip().strip('()')
                try:
                    x, y = map(float, pos_str.split(','))
                    self.start_pos = (x, y)
                except ValueError as e:
                    print(f"Error parsing start position: {e}")
    
    def create_default_maze(self):
        """ÂàõÂª∫ÈªòËÆ§Ëø∑ÂÆ´"""
        self.walls = [
            ((0, 0), (1, 0)),
            ((1, 0), (1, 2)),
            ((1, 1), (3, 1)),
            ((1, 2), (2, 2)),
            ((2, 2), (2, 3)),
            ((2, 0), (4, 0)),
            ((4, 0), (4, 4)),
            ((0, 4), (4, 4)),
            ((0, 0), (0, 3)),
            ((1, 3), (1, 4)),
            ((3, 3), (3, 4))
        ]
        self.start_pos = (1.5, 0.5)
        self.exits = [(0.5, 3.5)]
        self.size = 4
    
    def calculate_maze_size(self):
        """ËÆ°ÁÆóËø∑ÂÆ´Â§ßÂ∞è"""
        if not self.walls:
            self.size = 6
            return
        
        max_coord = 0
        for wall in self.walls:
            (x1, y1), (x2, y2) = wall
            max_coord = max(max_coord, x1, x2, y1, y2)
        
        self.size = max_coord
        
        if self.display_size < self.size + 2:
            self.display_size = int(self.size + 2)
    
    def find_exits(self):
        """ÂØªÊâæÂá∫Âè£"""
        self.exits = []
        boundary_walls = self.get_boundary_walls()
        
        # Ê£ÄÊü•ÂêÑËæπÁïåÁöÑÂºÄÂè£
        for side in ['top', 'right', 'bottom', 'left']:
            gaps = self.find_boundary_gaps(boundary_walls, side)
            for gap in gaps:
                if side == 'top':
                    exit_pos = ((gap[0] + gap[1]) / 2, self.size - 0.1)
                elif side == 'right':
                    exit_pos = (self.size - 0.1, (gap[0] + gap[1]) / 2)
                elif side == 'bottom':
                    exit_pos = ((gap[0] + gap[1]) / 2, 0.1)
                else:  # left
                    exit_pos = (0.1, (gap[0] + gap[1]) / 2)
                self.exits.append(exit_pos)
    
    def get_boundary_walls(self):
        """Ëé∑ÂèñËæπÁïåÂ¢ôÂ£Å"""
        boundary_walls = {'top': [], 'bottom': [], 'left': [], 'right': []}
        
        for wall in self.walls:
            (x1, y1), (x2, y2) = wall
            
            if y1 == self.size and y2 == self.size:
                boundary_walls['top'].append((min(x1, x2), max(x1, x2)))
            elif y1 == 0 and y2 == 0:
                boundary_walls['bottom'].append((min(x1, x2), max(x1, x2)))
            elif x1 == 0 and x2 == 0:
                boundary_walls['left'].append((min(y1, y2), max(y1, y2)))
            elif x1 == self.size and x2 == self.size:
                boundary_walls['right'].append((min(y1, y2), max(y1, y2)))
        
        return boundary_walls
    
    def find_boundary_gaps(self, boundary_walls, side):
        """Êü•ÊâæËæπÁïåÂºÄÂè£"""
        walls = boundary_walls[side]
        if not walls:
            return [(0, self.size)]
        
        walls.sort()
        gaps = []
        
        if side in ['top', 'bottom']:
            if walls[0][0] > 0:
                gaps.append((0, walls[0][0]))
            
            for i in range(len(walls) - 1):
                if walls[i][1] < walls[i+1][0]:
                    gaps.append((walls[i][1], walls[i+1][0]))
            
            if walls[-1][1] < self.size:
                gaps.append((walls[-1][1], self.size))
        else:
            if walls[0][0] > 0:
                gaps.append((0, walls[0][0]))
            
            for i in range(len(walls) - 1):
                if walls[i][1] < walls[i+1][0]:
                    gaps.append((walls[i][1], walls[i+1][0]))
            
            if walls[-1][1] < self.size:
                gaps.append((walls[-1][1], self.size))
        
        return gaps
    
    def add_discovered_exit(self, exit_position):
        """Ê∑ªÂä†Âä®ÊÄÅÂèëÁé∞ÁöÑÂá∫Âè£"""
        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂèëÁé∞ËøáËøô‰∏™Âá∫Âè£ÔºàÈÅøÂÖçÈáçÂ§çÔºâ
        for existing_exit in self.discovered_exits:
            distance = math.sqrt((exit_position[0] - existing_exit[0])**2 + 
                               (exit_position[1] - existing_exit[1])**2)
            if distance < 1.0:  # Â¶ÇÊûúË∑ùÁ¶ªÂ∞è‰∫é1Âçï‰ΩçÔºåËÆ§‰∏∫ÊòØÂêå‰∏Ä‰∏™Âá∫Âè£
                return False
        
        self.discovered_exits.append(exit_position)
        print(f"üéØ NEW EXIT DISCOVERED at ({exit_position[0]:.2f}, {exit_position[1]:.2f})")
        print(f"üìç Total discovered exits: {len(self.discovered_exits)}")
        return True
    
    def mark_exit_reached(self, robot_position):
        """Ê†áËÆ∞Êú∫Âô®‰∫∫Âà∞ËææÂá∫Âè£ÁöÑÁ°ÆÂàá‰ΩçÁΩÆ"""
        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊ†áËÆ∞ËøáËøô‰∏™‰ΩçÁΩÆÔºàÈÅøÂÖçÈáçÂ§çÔºâ
        for existing_pos in self.reached_exit_positions:
            distance = math.sqrt((robot_position[0] - existing_pos[0])**2 + 
                               (robot_position[1] - existing_pos[1])**2)
            if distance < 0.5:  # Â¶ÇÊûúË∑ùÁ¶ªÂ∞è‰∫é0.5Âçï‰ΩçÔºåËÆ§‰∏∫ÊòØÂêå‰∏Ä‰∏™‰ΩçÁΩÆ
                return False
        
        self.reached_exit_positions.append(robot_position)
        # ÂêåÊó∂Â∞ÜÂÖ∂ËßÜ‰∏∫Â∑≤Ê£ÄÊµãÂà∞ÁöÑÂá∫Âè£Ôºå‰æø‰∫éÁ≥ªÁªüÁªü‰∏ÄÂ§ÑÁêÜ
        self.exit_detected = True
        self.exit_position = robot_position
        return True
    
    def can_move_to(self, from_pos, to_pos):
        """Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆÔºàÂÖÅËÆ∏Âú®Êâ©Â±ïÂå∫Âüü -2 Âà∞ size+2 ÂÜÖÁßªÂä®Ôºâ"""
        # ÂÖÅËÆ∏Â∞èËΩ¶Âú®ÂÆåÊï¥Êâ©Â±ïÂå∫Âüü (-2, size+2) ËåÉÂõ¥ÂÜÖÁßªÂä®ÔºåÂåÖÊã¨ -2 Âà∞ 0 ÁöÑÂ∑¶‰∏ãÂå∫Âüü
        extended_margin = 2.0
        if not (-extended_margin <= to_pos[0] <= self.size + extended_margin and
                -extended_margin <= to_pos[1] <= self.size + extended_margin):
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶‰∏éÂ¢ôÂ£ÅÁ¢∞Êíû
        for wall in self.walls + self.invisible_walls:
            if self._line_intersect_segment(from_pos, to_pos, wall[0], wall[1]):
                return False
        
        return True
    
    def _line_intersect_segment(self, p1, p2, p3, p4):
        """Ê£ÄÊü•Á∫øÊÆµÊòØÂê¶Áõ∏‰∫§"""
        def ccw(A, B, C):
            return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])
        
        return ccw(p1, p3, p4) != ccw(p2, p3, p4) and ccw(p1, p2, p3) != ccw(p1, p2, p4)

    def _setup_virtual_entrance(self):


        # ÈúÄË¶Å size Âíå start_pos Â∑≤ÁªèÁ°ÆÂÆö
        if self.size is None or self.start_pos is None:
            return

        orig_x, orig_y = self.start_pos

        # ËÆ∞ÂΩïÊòØÂê¶ÁßªÂä®ÂèäÊñ∞Â¢ûÂ¢ô‰Ωì
        moved = False

        # Âà§Êñ≠È°∂ËæπÁïå (y == size)
        if abs(orig_y - self.size) < 1e-6:
            # Êñ∞Ëµ∑ÁÇπÂêë‰∏ãÁßª 1
            self.start_pos = (orig_x, orig_y - 1)
            # Âú®Âéü y==size Â§ÑÊîæÁΩÆÊ∞¥Âπ≥ÈöêÂΩ¢Â¢ôÔºåÈïøÂ∫¶ 2Ôºàorig_x-1 Âà∞ orig_x+1Ôºâ
            self.invisible_walls.append(((orig_x - 1, self.size), (orig_x + 1, self.size)))
            moved = True

        # Âà§Êñ≠Â∫ïËæπÁïå (y == 0)
        if abs(orig_y - 0) < 1e-6:
            self.start_pos = (orig_x, orig_y + 1)
            self.invisible_walls.append(((orig_x - 1, 0), (orig_x + 1, 0)))
            moved = True

        # Âà§Êñ≠Â∑¶ËæπÁïå (x == 0)
        if abs(orig_x - 0) < 1e-6:
            self.start_pos = (orig_x + 1, self.start_pos[1])
            self.invisible_walls.append(((0, orig_y - 1), (0, orig_y + 1)))
            moved = True

        # Âà§Êñ≠Âè≥ËæπÁïå (x == size)
        if abs(orig_x - self.size) < 1e-6:
            self.start_pos = (orig_x - 1, self.start_pos[1])
            self.invisible_walls.append(((self.size, orig_y - 1), (self.size, orig_y + 1)))
            moved = True

        if moved:
            print(f"üöß Virtual entrance walls added, new start_pos: {self.start_pos}, total invisible walls: {len(self.invisible_walls)}")

class GlobalSLAMMapper:
    """ÂÖ®Â±ÄÂÖ±‰∫´SLAMÂú∞Âõæ"""
    
    def __init__(self, maze_size, display_size=18, resolution=0.1):
        self.size = maze_size
        self.display_size = display_size
        self.resolution = resolution
        self.grid_size = int(display_size / resolution)
        
        # ÂÖ®Â±ÄSLAMÂú∞ÂõæÔºö0=Êú™Áü•Ôºå1=Ëá™Áî±Ôºå2=Âç†Áî®
        self.global_map = np.zeros((self.grid_size, self.grid_size), dtype=int)
        
        # ÊîπËøõÁöÑÂâçÊ≤øÁÇπÁÆ°ÁêÜ
        self.frontiers = set()
        self.frontier_info = {}  # Â≠òÂÇ®ÊØè‰∏™frontierÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
        self.frontier_last_seen = {}  # ËÆ∞ÂΩïfrontierÊúÄÂêéË¢´Á°ÆËÆ§ÁöÑÊó∂Èó¥
        self.frontier_exploration_value = {}  # ËÆ∞ÂΩïfrontierÁöÑÊé¢Á¥¢‰ª∑ÂÄº
        self.update_counter = 0  # Êõ¥Êñ∞ËÆ°Êï∞Âô®
        
        # Êé¢Á¥¢‰ø°ÊÅØ
        self.all_explored_cells = set()
        self.robot_paths = {}  # Â≠òÂÇ®ÊâÄÊúâÊú∫Âô®‰∫∫ÁöÑË∑ØÂæÑ
        
        # ‰øùÂ≠òmaze_envÂºïÁî®ÔºàÁ®çÂêéËÆæÁΩÆÔºâ
        self.maze_env = None
        
    def set_maze_env(self, maze_env):
        """ËÆæÁΩÆËø∑ÂÆ´ÁéØÂ¢ÉÂºïÁî®"""
        self.maze_env = maze_env
        
    def world_to_grid(self, world_pos):
        """‰∏ñÁïåÂùêÊ†áËΩ¨ÁΩëÊ†ºÂùêÊ†á"""
        x, y = world_pos
        # ÊîØÊåÅË¥üÂùêÊ†áÔºöÂ∞Ü -2 Âà∞ display_size-2 ÁöÑ‰∏ñÁïåÂùêÊ†áÊò†Â∞ÑÂà∞ 0 Âà∞ grid_size-1 ÁöÑÁΩëÊ†º
        offset = 2.0  # ÂÅèÁßªÈáèÔºåÂõ†‰∏∫‰∏ñÁïåÂùêÊ†áÂèØ‰ª•‰ªé -2 ÂºÄÂßã
        grid_x = int((x + offset) / self.resolution)
        grid_y = int((y + offset) / self.resolution)
        return (min(max(grid_x, 0), self.grid_size-1), 
                min(max(grid_y, 0), self.grid_size-1))
    
    def grid_to_world(self, grid_pos):
        """ÁΩëÊ†ºÂùêÊ†áËΩ¨‰∏ñÁïåÂùêÊ†á"""
        grid_x, grid_y = grid_pos
        # ÊîØÊåÅË¥üÂùêÊ†áÔºöÂèçÂêëËΩ¨Êç¢
        offset = 2.0
        x = grid_x * self.resolution - offset
        y = grid_y * self.resolution - offset
        return (x, y)
    
    def update_map(self, robot_id, robot_pos, scan_points, obstacle_points):
        """Êõ¥Êñ∞ÂÖ®Â±ÄÂú∞Âõæ"""
        # ËÆ∞ÂΩïÊú∫Âô®‰∫∫Ë∑ØÂæÑ
        if robot_id not in self.robot_paths:
            self.robot_paths[robot_id] = []
        self.robot_paths[robot_id].append(robot_pos)
        
        # Ê†áËÆ∞Êú∫Âô®‰∫∫‰ΩçÁΩÆ‰∏∫Ëá™Áî±Á©∫Èó¥
        robot_grid = self.world_to_grid(robot_pos)
        rx, ry = robot_grid
        if 0 <= rx < self.grid_size and 0 <= ry < self.grid_size:
            self.global_map[ry, rx] = 1
            self.all_explored_cells.add((rx, ry))
        
        # Â§ÑÁêÜËá™Áî±Á©∫Èó¥Êâ´ÊèèÁÇπ
        for point in scan_points:
            grid_pos = self.world_to_grid(point)
            px, py = grid_pos
            if 0 <= px < self.grid_size and 0 <= py < self.grid_size:
                if self.global_map[py, px] == 0:  # Âè™Êõ¥Êñ∞Êú™Áü•Âå∫Âüü
                    self.global_map[py, px] = 1
                    self.all_explored_cells.add((px, py))
        
        # Â§ÑÁêÜÈöúÁ¢çÁâ©ÁÇπÔºà‰ºòÂÖàÁ∫ßÊõ¥È´òÔºâ
        for point in obstacle_points:
            grid_pos = self.world_to_grid(point)
            px, py = grid_pos
            if 0 <= px < self.grid_size and 0 <= py < self.grid_size:
                self.global_map[py, px] = 2
                self.all_explored_cells.add((px, py))
        
        # Êõ¥Êñ∞ÂâçÊ≤øÁÇπ
        self.update_frontiers()
    
    def update_frontiers(self):
        """ÊîπËøõÁöÑÂâçÊ≤øÁÇπÊõ¥Êñ∞ÔºàÊô∫ËÉΩÁÆ°ÁêÜÁâàÔºâ"""
        self.update_counter += 1
        current_valid_frontiers = set()
        
        # È´òÈÄüÊ®°ÂºèÔºöÂè™Ê£ÄÊü•ÊúÄËøëÁöÑÊé¢Á¥¢ÁÇπÔºåÂáèÂ∞ëËÆ°ÁÆóÈáè
        recent_cells = list(self.all_explored_cells)[-200:] if len(self.all_explored_cells) > 200 else self.all_explored_cells
        
        # Ê£ÄÊü•ÊúÄËøëÁöÑËá™Áî±Á©∫Èó¥ÈÇªÂ±ÖÔºåÂèëÁé∞Êñ∞ÁöÑpotential frontiers
        for x, y in recent_cells:
            if self.global_map[y, x] == 1:  # Ëá™Áî±Á©∫Èó¥
                # Ê£ÄÊü•8ÈÇªÂüüÔºàÂåÖÊã¨ÂØπËßíÁ∫øÔºâ
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:
                    nx, ny = x + dx, y + dy
                    if (0 <= nx < self.grid_size and 
                        0 <= ny < self.grid_size and
                        self.global_map[ny, nx] == 0):  # Êú™Áü•Âå∫Âüü
                        
                        # È™åËØÅÂâçÊ≤øÁÇπÔºöÁ°Æ‰øù‰∏çÂú®Â¢ô‰∏ä‰∏îÂèØËææ
                        world_pos = self.grid_to_world((nx, ny))
                        if self._is_valid_frontier(world_pos, (x, y)):
                            current_valid_frontiers.add(world_pos)
                            
                            # Êõ¥Êñ∞frontier‰ø°ÊÅØ
                            if world_pos not in self.frontier_info:
                                # Êñ∞ÂèëÁé∞ÁöÑfrontier
                                self.frontier_info[world_pos] = {
                                    'birth_time': self.update_counter,
                                    'discovery_count': 1,
                                    'nearby_unknown_cells': self._count_nearby_unknown(world_pos)
                                }
                            else:
                                # Â∑≤Áü•frontierÔºåÊõ¥Êñ∞‰ø°ÊÅØ
                                self.frontier_info[world_pos]['discovery_count'] += 1
                                self.frontier_info[world_pos]['nearby_unknown_cells'] = self._count_nearby_unknown(world_pos)
                            
                            # Êõ¥Êñ∞ÊúÄÂêéÁ°ÆËÆ§Êó∂Èó¥
                            self.frontier_last_seen[world_pos] = self.update_counter
                            
                            # ËÆ°ÁÆóÊé¢Á¥¢‰ª∑ÂÄº
                            self._update_exploration_value(world_pos)
        
        # Êô∫ËÉΩÁßªÈô§Á≠ñÁï•Ôºö‰∏çÊòØÁÆÄÂçïÊõøÊç¢ÔºåËÄåÊòØÂü∫‰∫éÂ§ö‰∏™Êù°‰ª∂
        frontiers_to_remove = set()
        
        for frontier in self.frontiers:
            should_remove = False
            
            # Êù°‰ª∂1ÔºöÂ¶ÇÊûúfrontier‰∏çÂÜçÊúâÊïàÔºàË¢´ÂÆåÂÖ®Êé¢Á¥¢Ôºâ
            if frontier not in current_valid_frontiers:
                # Áªô‰∫à‰∏ÄÂÆöÁöÑÂÆΩÂÆπÊúüÔºåÈÅøÂÖçËøáÊó©ÁßªÈô§
                if (self.update_counter - self.frontier_last_seen.get(frontier, 0)) > 5:
                    # Ê£ÄÊü•ÊòØÂê¶ÁúüÁöÑË¢´ÂÆåÂÖ®Êé¢Á¥¢
                    nearby_unknown = self._count_nearby_unknown(frontier)
                    if nearby_unknown == 0:
                        should_remove = True
            
            # Êù°‰ª∂2ÔºöÂ¶ÇÊûúfrontierÁöÑÊé¢Á¥¢‰ª∑ÂÄºÂ§™‰Ωé‰∏îÂ≠òÂú®Êó∂Èó¥ËøáÈïø
            if frontier in self.frontier_exploration_value:
                age = self.update_counter - self.frontier_info.get(frontier, {}).get('birth_time', 0)
                value = self.frontier_exploration_value[frontier]
                
                # ‰Ωé‰ª∑ÂÄº‰∏î"ËÄÅÂåñ"ÁöÑfrontierÂèØ‰ª•Ë¢´ÁßªÈô§
                if age > 20 and value < 0.3:
                    should_remove = True
                    print(f"üóëÔ∏è  Removing low-value old frontier at ({frontier[0]:.1f}, {frontier[1]:.1f}) - value: {value:.2f}, age: {age}")
            
            if should_remove:
                frontiers_to_remove.add(frontier)
        
        # ÁßªÈô§Ê†áËÆ∞ÁöÑfrontiers
        for frontier in frontiers_to_remove:
            self.frontiers.discard(frontier)
            self.frontier_info.pop(frontier, None)
            self.frontier_last_seen.pop(frontier, None)
            self.frontier_exploration_value.pop(frontier, None)
        
        # Ê∑ªÂä†Êñ∞ÁöÑÊúâÊïàfrontiers
        new_frontiers = current_valid_frontiers - self.frontiers
        self.frontiers.update(new_frontiers)

    
    def _count_nearby_unknown(self, world_pos):
        """ËÆ°ÁÆófrontierÂë®Âõ¥ÁöÑÊú™Áü•Âå∫ÂüüÊï∞Èáè"""
        frontier_grid = self.world_to_grid(world_pos)
        fx, fy = frontier_grid
        
        unknown_count = 0
        for dx in range(-2, 3):  # Êâ©Â§ßÊ£ÄÊü•ËåÉÂõ¥
            for dy in range(-2, 3):
                nx, ny = fx + dx, fy + dy
                if (0 <= nx < self.grid_size and 0 <= ny < self.grid_size):
                    if self.global_map[ny, nx] == 0:  # Êú™Áü•Âå∫Âüü
                        unknown_count += 1
        
        return unknown_count
    
    def _update_exploration_value(self, world_pos):
        """Êõ¥Êñ∞frontierÁöÑÊé¢Á¥¢‰ª∑ÂÄº"""
        if world_pos not in self.frontier_info:
            return
        
        info = self.frontier_info[world_pos]
        
        # Âü∫Á°Ä‰ª∑ÂÄºÔºöÂü∫‰∫éÂë®Âõ¥Êú™Áü•Âå∫ÂüüÊï∞Èáè
        unknown_value = min(info['nearby_unknown_cells'] / 10.0, 1.0)
        
        # ÊåÅ‰πÖÊÄß‰ª∑ÂÄºÔºöÁªèÂ∏∏Ë¢´ÈáçÊñ∞ÂèëÁé∞ÁöÑfrontier‰ª∑ÂÄºÊõ¥È´ò
        persistence_value = min(info['discovery_count'] / 5.0, 1.0)
        
        # Âπ¥ÈæÑË°∞ÂáèÔºöÂ§™ËÄÅÁöÑfrontier‰ª∑ÂÄºÈôç‰Ωé
        age = self.update_counter - info['birth_time']
        age_factor = max(0.3, 1.0 - age / 50.0)
        
        # ‰ΩçÁΩÆ‰ª∑ÂÄºÔºöËæπÁïåÈôÑËøëÁöÑfrontier‰ª∑ÂÄºÊõ¥È´ò
        boundary_value = self._calculate_boundary_value(world_pos)
        
        # ÁªºÂêà‰ª∑ÂÄº
        total_value = (unknown_value * 0.4 + 
                      persistence_value * 0.2 + 
                      boundary_value * 0.3 + 
                      age_factor * 0.1)
        
        self.frontier_exploration_value[world_pos] = total_value
    
    def _calculate_boundary_value(self, world_pos):
        """ËÆ°ÁÆóËæπÁïå‰ª∑ÂÄºÔºàËæπÁïåÈôÑËøëÁöÑÂâçÊ≤øÁÇπ‰ª∑ÂÄºÊõ¥È´òÔºâ"""
        x, y = world_pos
        
        # ËÆ°ÁÆóÂà∞ÂêÑËæπÁïåÁöÑË∑ùÁ¶ª
        dist_to_left = abs(x - 0)
        dist_to_right = abs(x - self.size)
        dist_to_bottom = abs(y - 0)
        dist_to_top = abs(y - self.size)
        
        min_boundary_dist = min(dist_to_left, dist_to_right, dist_to_bottom, dist_to_top)
        
        # Ê£ÄÊü•ÊòØÂê¶Âú® -2 Âà∞ 0 ÁöÑÊâ©Â±ïÂå∫ÂüüÔºà‰ºòÂÖàÁ∫ßËæÉ‰ΩéÔºâ
        in_negative_extension = (x < 0 or y < 0)
        
        # Ê£ÄÊü•ÊòØÂê¶Âú® size Âà∞ size+2 ÁöÑÊâ©Â±ïÂå∫ÂüüÔºà‰ºòÂÖàÁ∫ßËæÉ‰ΩéÔºâ
        in_positive_extension = (x > self.size or y > self.size)
        
        # ËæπÁïåÈôÑËøëÁöÑÂâçÊ≤øÁÇπÊõ¥Êúâ‰ª∑ÂÄº
        if min_boundary_dist < 1.0:
            # Êâ©Â±ïÂå∫ÂüüÁöÑËæπÁïåÁÇπ‰ª∑ÂÄºËæÉ‰Ωé
            if in_negative_extension or in_positive_extension:
                return 0.4  # ËæÉ‰Ωé‰ºòÂÖàÁ∫ß
            else:
                return 0.8  # Ê≠£Â∏∏ËæπÁïå‰ºòÂÖàÁ∫ß
        elif min_boundary_dist < 2.0:
            if in_negative_extension or in_positive_extension:
                return 0.3
            else:
                return 0.6
        else:
            return 0.4
    
    def _is_valid_frontier(self, world_pos, from_grid):
        """È™åËØÅÂâçÊ≤øÁÇπÊòØÂê¶ÊúâÊïàÔºà‰∏çÂú®Â¢ô‰∏äÔºåÂèØËææÔºåÂú®Êâ©Â±ïÊòæÁ§∫Âå∫ÂüüÂÜÖÔºâ"""
        # 1. Êâ©Â±ïËæπÁïåÊ£ÄÊü•ÔºöÂÖÅËÆ∏Âú®Êâ©Â±ïÂå∫ÂüüÔºà-2Âà∞max+2ÔºâÊ†áËÆ∞ËæπÁºòÁÇπ
        if not (-1.8 <= world_pos[0] <= self.display_size + 1.8 and 
                -1.8 <= world_pos[1] <= self.display_size + 1.8):
            return False
        
        # 2. Á°Æ‰øùÂâçÊ≤øÁÇπÁ°ÆÂÆûÊòØÊé¢Á¥¢ËæπÁïåÔºàÂë®Âõ¥ÊúâË∂≥Â§üÁöÑÊú™Áü•Âå∫ÂüüÔºâ
        frontier_grid = self.world_to_grid(world_pos)
        fx, fy = frontier_grid
        
        # Ê£ÄÊü•Âë®Âõ¥ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÊú™Áü•Âå∫ÂüüÔºåÁ°ÆËÆ§ËøôÊòØÁúüÊ≠£ÁöÑËæπÁïå
        unknown_neighbors = 0
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                nx, ny = fx + dx, fy + dy
                if (0 <= nx < self.grid_size and 0 <= ny < self.grid_size):
                    if self.global_map[ny, nx] == 0:  # Êú™Áü•Âå∫Âüü
                        unknown_neighbors += 1
        
        # Ëá≥Â∞ëÈúÄË¶Å2‰∏™Êú™Áü•ÈÇªÂ±ÖÊâçÁÆóÁúüÊ≠£ÁöÑËæπÁïåÔºàÊîæÂÆΩË¶ÅÊ±ÇÔºâ
        if unknown_neighbors < 2:
            return False
        
        # 3. ‰∏•Ê†ºÁöÑÂ¢ôÂ£ÅÊ£ÄÊµã - ÂØπÊâÄÊúâÂå∫ÂüüÈÉΩËøõË°åÊ£ÄÊü•
        if self.maze_env:
            # Ê£ÄÊü•ÂâçÊ≤øÁÇπÊòØÂê¶‰∏é‰ªª‰ΩïÂ¢ôÂ£ÅÈáçÂè†ÊàñÂ§™Ëøë
            min_distance_to_wall = 0.3  # Â¢ûÂä†ÊúÄÂ∞èË∑ùÁ¶ªÂà∞Â¢ôÂ£ÅÔºåÈò≤Ê≠¢Á©øÂ¢ô
            
            for wall in self.maze_env.walls + self.maze_env.invisible_walls:
                distance = self._point_to_line_distance(world_pos, wall[0], wall[1])
                if distance < min_distance_to_wall:
                    return False
            
            # 4. ËøûÈÄöÊÄßÊ£ÄÊü• - Âè™ÂØπÂèØËÆøÈóÆÂå∫ÂüüËøõË°å
            is_in_accessible_area = (0 <= world_pos[0] <= self.maze_env.size and 
                                    0 <= world_pos[1] <= self.maze_env.size)
            
            if is_in_accessible_area:
                # Ê£ÄÊü•‰ªéÂ∑≤Áü•Ëá™Áî±Á©∫Èó¥Âà∞ÂâçÊ≤øÁÇπÁöÑËøûÈÄöÊÄß
                from_world = self.grid_to_world(from_grid)
                if not self.maze_env.can_move_to(from_world, world_pos):
                    return False
            
            # 5. È¢ùÂ§ñÁöÑÂ¢ôÂ£ÅÁ©øÈÄèÊ£ÄÊü• - Ê£ÄÊü•ÂâçÊ≤øÁÇπÂë®Âõ¥ÁöÑÂ∞èÂå∫Âüü
            check_radius = 0.2
            for angle in [0, 45, 90, 135, 180, 225, 270, 315]:
                check_x = world_pos[0] + check_radius * math.cos(math.radians(angle))
                check_y = world_pos[1] + check_radius * math.sin(math.radians(angle))
                check_pos = (check_x, check_y)
                
                for wall in self.maze_env.walls + self.maze_env.invisible_walls:
                    distance = self._point_to_line_distance(check_pos, wall[0], wall[1])
                    if distance < 0.1:  # Â¶ÇÊûúÂë®Âõ¥ÁÇπÂ§™Èù†ËøëÂ¢ôÂ£ÅÔºå‰πüÊãíÁªù
                        return False
        
        return True
    
    def _is_frontier_reachable(self, frontier_world, from_grid):
        """Ê£ÄÊü•ÂâçÊ≤øÁÇπÊòØÂê¶ÂèØËææÔºà‰∏çË¢´Â¢ôÈòªÊå°Ôºâ"""
        from_world = self.grid_to_world(from_grid)
        
        # Âü∫Á°ÄËæπÁïåÊ£ÄÊü•
        if not (0.2 <= frontier_world[0] <= self.display_size - 0.2 and 
                0.2 <= frontier_world[1] <= self.display_size - 0.2):
            return False
        
        # Â¶ÇÊûúÊúâmaze_envÔºåËøõË°åÊõ¥ËØ¶ÁªÜÁöÑÊ£ÄÊü•
        if self.maze_env:
            # Ê£ÄÊü•ÂâçÊ≤øÁÇπÊòØÂê¶‰∏éÂ¢ôÂ£ÅÂ§™Ëøë
            safety_distance = 0.2
            for wall in self.maze_env.walls + self.maze_env.invisible_walls:
                if self._point_to_line_distance(frontier_world, wall[0], wall[1]) < safety_distance:
                    return False
            
            # Ê£ÄÊü•‰ªéÂ∑≤Áü•Ëá™Áî±Á©∫Èó¥Âà∞ÂâçÊ≤øÁÇπÁöÑË∑ØÂæÑ
            if not self.maze_env.can_move_to(from_world, frontier_world):
                return False
        
        return True
    
    def _point_to_line_distance(self, point, line_start, line_end):
        """ËÆ°ÁÆóÁÇπÂà∞Á∫øÊÆµÁöÑË∑ùÁ¶ª"""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        # Á∫øÊÆµÈïøÂ∫¶
        line_len = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        if line_len == 0:
            return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)
        
        # ËÆ°ÁÆóÊäïÂΩ±ÂèÇÊï∞
        t = max(0, min(1, ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / (line_len**2)))
        
        # ÊäïÂΩ±ÁÇπ
        proj_x = x1 + t * (x2 - x1)
        proj_y = y1 + t * (y2 - y1)
        
        # Ë∑ùÁ¶ª
        return math.sqrt((x0 - proj_x)**2 + (y0 - proj_y)**2)
    
    def get_nearest_frontier(self, robot_pos):
        """Ëé∑ÂèñÊúÄ‰ºòÂâçÊ≤øÁÇπÔºà‰ºòÂÖàÂèØËÆøÈóÆÂå∫ÂüüÔºåÁªºÂêàË∑ùÁ¶ªÂíå‰ª∑ÂÄºÔºâ"""
        if not self.frontiers:
            return None
        
        # ÂàÜÁ¶ªÂèØËÆøÈóÆÂå∫ÂüüÂíåÊâ©Â±ïÂå∫ÂüüÁöÑfrontiers
        accessible_frontiers = []
        extended_frontiers = []
        
        for frontier in self.frontiers:
            if (0 <= frontier[0] <= self.maze_env.size and 
                0 <= frontier[1] <= self.maze_env.size):
                accessible_frontiers.append(frontier)
            else:
                extended_frontiers.append(frontier)
        
        # ‰ºòÂÖàÈÄâÊã©ÂèØËÆøÈóÆÂå∫ÂüüÁöÑfrontiers
        target_frontiers = accessible_frontiers if accessible_frontiers else extended_frontiers
        
        if not target_frontiers:
            return None
        
        best_score = float('-inf')
        best_frontier = None
        area_type = "accessible" if accessible_frontiers else "extended"
        
        for frontier in target_frontiers:
            # ËÆ°ÁÆóË∑ùÁ¶ª
            dist = math.sqrt((robot_pos[0] - frontier[0])**2 + 
                           (robot_pos[1] - frontier[1])**2)
            
            # Ëé∑ÂèñÊé¢Á¥¢‰ª∑ÂÄºÔºàÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî®ÈªòËÆ§ÂÄºÔºâ
            exploration_value = self.frontier_exploration_value.get(frontier, 0.5)
            
            # ÁªºÂêàËØÑÂàÜÔºöË∑ùÁ¶ªË∂äËøëË∂äÂ•ΩÔºå‰ª∑ÂÄºË∂äÈ´òË∂äÂ•Ω
            # ÂΩí‰∏ÄÂåñË∑ùÁ¶ªÂà∞0-1ËåÉÂõ¥
            max_possible_dist = math.sqrt(self.display_size**2 + self.display_size**2)
            normalized_dist = dist / max_possible_dist
            distance_score = 1.0 - normalized_dist
            
            # ÁªºÂêàËØÑÂàÜÔºö60%Áúã‰ª∑ÂÄºÔºå40%ÁúãË∑ùÁ¶ª
            total_score = exploration_value * 0.6 + distance_score * 0.4
            
            if total_score > best_score:
                best_score = total_score
                best_frontier = frontier
        
        if best_frontier and area_type == "extended":
            print(f"üéØ Selecting frontier from extended area: ({best_frontier[0]:.1f}, {best_frontier[1]:.1f})")
        
        return best_frontier
    
    def assign_frontiers_to_robots(self, robot_positions):
        """‰∏∫Â§ö‰∏™Êú∫Âô®‰∫∫ÂàÜÈÖç‰∏çÂêåÁöÑÂâçÊ≤øÁõÆÊ†áÔºà‰ºòÂÖàÂèØËÆøÈóÆÂå∫ÂüüÔºâ"""
        if not self.frontiers:
            return {}
        
        # ÂàÜÁ¶ªÂèØËÆøÈóÆÂå∫ÂüüÂíåÊâ©Â±ïÂå∫ÂüüÁöÑfrontiers
        accessible_frontiers = []
        extended_frontiers = []
        
        for frontier in self.frontiers:
            if (0 <= frontier[0] <= self.maze_env.size and 
                0 <= frontier[1] <= self.maze_env.size):
                accessible_frontiers.append(frontier)
            else:
                extended_frontiers.append(frontier)
        
        assignments = {}
        
        # ‰ºòÂÖàÂàÜÈÖçÂèØËÆøÈóÆÂå∫ÂüüÁöÑfrontiers
        available_accessible = accessible_frontiers.copy()
        
        for robot_id, pos in robot_positions.items():
            if not available_accessible:
                break
            
            best_score = float('-inf')
            best_frontier = None
            best_idx = -1
            
            for i, frontier in enumerate(available_accessible):
                # ËÆ°ÁÆóË∑ùÁ¶ª
                dist = math.sqrt((pos[0] - frontier[0])**2 + (pos[1] - frontier[1])**2)
                
                # Ëé∑ÂèñÊé¢Á¥¢‰ª∑ÂÄº
                exploration_value = self.frontier_exploration_value.get(frontier, 0.5)
                
                # ÁªºÂêàËØÑÂàÜ
                max_possible_dist = math.sqrt(self.display_size**2 + self.display_size**2)
                normalized_dist = dist / max_possible_dist
                distance_score = 1.0 - normalized_dist
                total_score = exploration_value * 0.6 + distance_score * 0.4
                
                if total_score > best_score:
                    best_score = total_score
                    best_frontier = frontier
                    best_idx = i
            
            if best_frontier:
                assignments[robot_id] = best_frontier
                available_accessible.pop(best_idx)
        
        # Â¶ÇÊûúËøòÊúâÊú∫Âô®‰∫∫Ê≤°ÊúâÂàÜÈÖçÂà∞ÂèØËÆøÈóÆÂå∫ÂüüÁöÑfrontierÔºåÂÜçÂàÜÈÖçÊâ©Â±ïÂå∫ÂüüÁöÑ
        unassigned_robots = [robot_id for robot_id in robot_positions.keys() if robot_id not in assignments]
        available_extended = extended_frontiers.copy()
        
        for robot_id in unassigned_robots:
            if not available_extended:
                break
            
            pos = robot_positions[robot_id]
            best_score = float('-inf')
            best_frontier = None
            best_idx = -1
            
            for i, frontier in enumerate(available_extended):
                # ËÆ°ÁÆóË∑ùÁ¶ª
                dist = math.sqrt((pos[0] - frontier[0])**2 + (pos[1] - frontier[1])**2)
                
                # Ëé∑ÂèñÊé¢Á¥¢‰ª∑ÂÄº
                exploration_value = self.frontier_exploration_value.get(frontier, 0.5)
                
                # ÁªºÂêàËØÑÂàÜ
                max_possible_dist = math.sqrt(self.display_size**2 + self.display_size**2)
                normalized_dist = dist / max_possible_dist
                distance_score = 1.0 - normalized_dist
                total_score = exploration_value * 0.6 + distance_score * 0.4
                
                if total_score > best_score:
                    best_score = total_score
                    best_frontier = frontier
                    best_idx = i
            
            if best_frontier:
                assignments[robot_id] = best_frontier
                available_extended.pop(best_idx)
                print(f"üéØ Robot {robot_id} assigned extended area frontier: ({best_frontier[0]:.1f}, {best_frontier[1]:.1f})")
        
        return assignments

class AStarPathPlanner:
    """A*Ë∑ØÂæÑËßÑÂàíÂô®ÔºàÈò≤Á©øÂ¢ôÁâàÊú¨Ôºâ"""
    
    def __init__(self, global_mapper, maze_env):
        self.mapper = global_mapper
        self.maze_env = maze_env
    
    def plan_path(self, start_pos, goal_pos):
        """‰ΩøÁî®A*ÁÆóÊ≥ïËßÑÂàíË∑ØÂæÑÔºà‰∏•Ê†ºÈò≤Á©øÂ¢ôÔºâ"""
        start_grid = self.mapper.world_to_grid(start_pos)
        goal_grid = self.mapper.world_to_grid(goal_pos)
        
        if start_grid == goal_grid:
            return [start_pos, goal_pos]
        
        # È™åËØÅÁõÆÊ†áÁÇπÊòØÂê¶ÂèØËææ
        goal_world = self.mapper.grid_to_world(goal_grid)
        if not self._is_position_safe(goal_world):
            # ÂØªÊâæÊúÄËøëÁöÑÂÆâÂÖ®ÁõÆÊ†áÁÇπ
            goal_grid = self._find_nearest_safe_position(goal_grid)
            if not goal_grid:
                return [start_pos]  # Êó†Ê≥ïÊâæÂà∞ÂÆâÂÖ®Ë∑ØÂæÑ
        
        # A*ÁÆóÊ≥ïÂÆûÁé∞
        open_set = []
        heapq.heappush(open_set, (0, start_grid))
        
        came_from = {}
        g_score = {start_grid: 0}
        f_score = {start_grid: self._heuristic(start_grid, goal_grid)}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == goal_grid:
                # ÈáçÊûÑË∑ØÂæÑÂπ∂È™åËØÅ
                path = self._reconstruct_path(came_from, current, start_pos)
                return self._smooth_and_validate_path(path)
            
            # Ê£ÄÊü•ÈÇªÂ±ÖÔºà4ÊñπÂêëÔºåÈÅøÂÖçÂØπËßíÁ∫øÁ©øÂ¢ôÔºâ
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                neighbor = (current[0] + dx, current[1] + dy)
                
                if self._is_grid_position_valid(neighbor):
                    # È™åËØÅÁßªÂä®ÊòØÂê¶ÂÆâÂÖ®Ôºà‰∏çÁ©øÂ¢ôÔºâ
                    current_world = self.mapper.grid_to_world(current)
                    neighbor_world = self.mapper.grid_to_world(neighbor)
                    
                    if self._is_movement_safe(current_world, neighbor_world):
                        tentative_g = g_score[current] + 1
                        
                        if neighbor not in g_score or tentative_g < g_score[neighbor]:
                            came_from[neighbor] = current
                            g_score[neighbor] = tentative_g
                            f_score[neighbor] = tentative_g + self._heuristic(neighbor, goal_grid)
                            heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        # Â¶ÇÊûúÊ≤°ÊâæÂà∞Ë∑ØÂæÑÔºåËøîÂõûÂΩìÂâç‰ΩçÁΩÆ
        return [start_pos]
    
    def _is_grid_position_valid(self, grid_pos):
        """Ê£ÄÊü•ÁΩëÊ†º‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà"""
        x, y = grid_pos
        if not (0 <= x < self.mapper.grid_size and 0 <= y < self.mapper.grid_size):
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶ÊòØÈöúÁ¢çÁâ©
        if self.mapper.global_map[y, x] == 2:
            return False
        
        return True
    
    def _is_position_safe(self, world_pos):
        """Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÂÆâÂÖ®Ôºà‰∏çÊíûÂ¢ô‰∏îÂú®ÂÖÅËÆ∏Âå∫ÂüüÂÜÖÔºâ"""
        x, y = world_pos
        
        # Ê£ÄÊü•ÊòØÂê¶Âú®ÂÆåÊï¥Êâ©Â±ïÂÖÅËÆ∏Âå∫ÂüüÂÜÖÔºåÂåÖÊã¨ -2 Âà∞ 0 Âå∫ÂüüÔºàÊé¢Á¥¢Êó∂ÈúÄË¶ÅÔºâ
        if not (-1.9 <= x <= self.maze_env.size + 1.9 and -1.9 <= y <= self.maze_env.size + 1.9):
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶‰∏éÂ¢ôÂ£ÅÂÜ≤Á™Å
        safety_radius = 0.15  # ÂÆâÂÖ®ÂçäÂæÑ
        
        for wall in self.maze_env.walls + self.maze_env.invisible_walls:
            if self._point_to_line_distance(world_pos, wall[0], wall[1]) < safety_radius:
                return False
        
        return True
    
    def _is_movement_safe(self, from_pos, to_pos):
        """Ê£ÄÊü•‰ªé‰∏Ä‰∏™‰ΩçÁΩÆÁßªÂä®Âà∞Âè¶‰∏Ä‰∏™‰ΩçÁΩÆÊòØÂê¶ÂÆâÂÖ®"""
        # ‰ΩøÁî®maze_envÁöÑcan_move_toÊñπÊ≥ï
        return self.maze_env.can_move_to(from_pos, to_pos) and self._is_position_safe(to_pos)
    
    def _find_nearest_safe_position(self, target_grid):
        """ÂØªÊâæÊúÄËøëÁöÑÂÆâÂÖ®‰ΩçÁΩÆ"""
        # Âú®ÁõÆÊ†áÂë®Âõ¥ÊêúÁ¥¢ÂÆâÂÖ®‰ΩçÁΩÆ
        for radius in range(1, 10):
            for dx in range(-radius, radius + 1):
                for dy in range(-radius, radius + 1):
                    if abs(dx) == radius or abs(dy) == radius:  # Âè™Ê£ÄÊü•ËæπÁïå
                        candidate = (target_grid[0] + dx, target_grid[1] + dy)
                        if self._is_grid_position_valid(candidate):
                            candidate_world = self.mapper.grid_to_world(candidate)
                            if self._is_position_safe(candidate_world):
                                return candidate
        return None
    
    def _reconstruct_path(self, came_from, current, start_pos):
        """ÈáçÊûÑË∑ØÂæÑ"""
        path = []
        while current in came_from:
            world_pos = self.mapper.grid_to_world(current)
            path.append(world_pos)
            current = came_from[current]
        path.append(start_pos)
        path.reverse()
        return path
    
    def _smooth_and_validate_path(self, path):
        """Âπ≥ÊªëÂπ∂È™åËØÅË∑ØÂæÑ"""
        if len(path) <= 2:
            return path
        
        smoothed_path = [path[0]]
        
        for i in range(1, len(path)):
            # È™åËØÅÊØè‰∏ÄÊ≠•ÁßªÂä®
            if self._is_movement_safe(smoothed_path[-1], path[i]):
                smoothed_path.append(path[i])
            else:
                # Â¶ÇÊûúÁõ¥Êé•ÁßªÂä®‰∏çÂÆâÂÖ®ÔºåÊ∑ªÂä†‰∏≠Èó¥ÁÇπ
                mid_point = ((smoothed_path[-1][0] + path[i][0]) / 2,
                           (smoothed_path[-1][1] + path[i][1]) / 2)
                if self._is_position_safe(mid_point):
                    smoothed_path.append(mid_point)
                smoothed_path.append(path[i])
        
        return smoothed_path
    
    def _point_to_line_distance(self, point, line_start, line_end):
        """ËÆ°ÁÆóÁÇπÂà∞Á∫øÊÆµÁöÑË∑ùÁ¶ª"""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        # Á∫øÊÆµÈïøÂ∫¶
        line_len = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        if line_len == 0:
            return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)
        
        # ËÆ°ÁÆóÊäïÂΩ±ÂèÇÊï∞
        t = max(0, min(1, ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / (line_len**2)))
        
        # ÊäïÂΩ±ÁÇπ
        proj_x = x1 + t * (x2 - x1)
        proj_y = y1 + t * (y2 - y1)
        
        # Ë∑ùÁ¶ª
        return math.sqrt((x0 - proj_x)**2 + (y0 - proj_y)**2)
    
    def _heuristic(self, a, b):
        """A*ÂêØÂèëÂºèÂáΩÊï∞ÔºàÊ¨ßÂá†ÈáåÂæóË∑ùÁ¶ªÔºâ"""
        return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

class OptimalPathPlanner:
    """‰∏ìÁî®‰∫éÊúÄÁü≠Ë∑ØÂæÑËÆ°ÁÆóÁöÑÂÖ´ÊñπÂêëA*Ë∑ØÂæÑËßÑÂàíÂô®"""
    
    def __init__(self, global_mapper, maze_env):
        self.mapper = global_mapper
        self.maze_env = maze_env
        # ÂÖ´ÊñπÂêëÁßªÂä®Ôºö4‰∏™Âü∫Êú¨ÊñπÂêë + 4‰∏™ÂØπËßíÁ∫øÊñπÂêë
        self.directions = [
            (-1, 0, 1.0),    # Â∑¶
            (1, 0, 1.0),     # Âè≥
            (0, -1, 1.0),    # ‰∏ã
            (0, 1, 1.0),     # ‰∏ä
            (-1, -1, 1.414), # Â∑¶‰∏ãÔºàÂØπËßíÁ∫øÔºâ
            (-1, 1, 1.414),  # Â∑¶‰∏äÔºàÂØπËßíÁ∫øÔºâ
            (1, -1, 1.414),  # Âè≥‰∏ãÔºàÂØπËßíÁ∫øÔºâ
            (1, 1, 1.414)    # Âè≥‰∏äÔºàÂØπËßíÁ∫øÔºâ
        ]
    
    def plan_optimal_path(self, start_pos, goal_pos):
        """ËÆ°ÁÆóÂÖ´ÊñπÂêëÊúÄ‰ºòË∑ØÂæÑ"""
        print(f"üéØ Planning optimal 8-direction path from {start_pos} to {goal_pos}")
        
        start_grid = self.mapper.world_to_grid(start_pos)
        goal_grid = self.mapper.world_to_grid(goal_pos)
        
        if start_grid == goal_grid:
            return [start_pos, goal_pos]
        
        # È™åËØÅËµ∑ÁÇπÂíåÁªàÁÇπ
        if not self._is_position_accessible(start_pos):
            print(f"‚ùå Start position not accessible: {start_pos}")
            return [start_pos]
        
        if not self._is_position_accessible(goal_pos):
            print(f"‚ùå Goal position not accessible: {goal_pos}")
            # ÂØªÊâæÊúÄËøëÁöÑÂèØËææÁõÆÊ†áÁÇπ
            goal_grid = self._find_nearest_accessible_position(goal_grid)
            if not goal_grid:
                return [start_pos]
            goal_pos = self.mapper.grid_to_world(goal_grid)
            print(f"‚úÖ Adjusted goal to: {goal_pos}")
        
        # A*ÁÆóÊ≥ïÂÆûÁé∞ÔºàÂÖ´ÊñπÂêëÁâàÊú¨Ôºâ
        open_set = []
        heapq.heappush(open_set, (0, start_grid))
        
        came_from = {}
        g_score = {start_grid: 0}
        f_score = {start_grid: self._heuristic(start_grid, goal_grid)}
        
        explored_nodes = 0
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            explored_nodes += 1
            
            if current == goal_grid:
                print(f"‚úÖ Path found! Explored {explored_nodes} nodes")
                path = self._reconstruct_optimal_path(came_from, current, start_pos, goal_pos)
                return self._smooth_optimal_path(path)
            
            # Ê£ÄÊü•ÂÖ´‰∏™ÊñπÂêëÁöÑÈÇªÂ±Ö
            for dx, dy, cost in self.directions:
                neighbor = (current[0] + dx, current[1] + dy)
                
                if self._is_grid_position_accessible(neighbor):
                    # Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÂÆâÂÖ®ÔºàÂåÖÊã¨ÂØπËßíÁ∫øÁßªÂä®Ôºâ
                    current_world = self.mapper.grid_to_world(current)
                    neighbor_world = self.mapper.grid_to_world(neighbor)
                    
                    if self._is_movement_safe(current_world, neighbor_world, is_diagonal=(cost > 1.0)):
                        tentative_g = g_score[current] + cost
                        
                        if neighbor not in g_score or tentative_g < g_score[neighbor]:
                            came_from[neighbor] = current
                            g_score[neighbor] = tentative_g
                            f_score[neighbor] = tentative_g + self._heuristic(neighbor, goal_grid)
                            heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        print(f"‚ùå No path found after exploring {explored_nodes} nodes")
        return [start_pos]
    
    def _is_position_accessible(self, world_pos):
        """Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÂèØËææÔºà‰∏•Ê†ºÈôêÂà∂Âú®Ëø∑ÂÆ´ÂÜÖÈÉ®ÔºåËøúÁ¶ªÂ¢ôÂ£ÅÔºâ"""
        x, y = world_pos
        
        # ‰∏•Ê†ºÈôêÂà∂Âú®Ëø∑ÂÆ´ÂÜÖÈÉ®Âå∫ÂüüÔºà0Âà∞sizeÔºâ
        margin = 0.3  # Â§ßÂπÖÂ¢ûÂä†ËæπË∑ùÁ°Æ‰øùÂÆâÂÖ®
        if not (margin <= x <= self.maze_env.size - margin and 
                margin <= y <= self.maze_env.size - margin):
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶‰∏éÂ¢ôÂ£ÅÂÜ≤Á™Å
        safety_radius = 0.35  # Â§ßÂπÖÂ¢ûÂä†ÂÆâÂÖ®ÂçäÂæÑ
        
        for wall in self.maze_env.walls + self.maze_env.invisible_walls:
            wall_dist = self._point_to_line_distance(world_pos, wall[0], wall[1])
            if wall_dist < safety_radius:
                return False
        
        return True
    
    def _is_grid_position_accessible(self, grid_pos):
        """Ê£ÄÊü•ÁΩëÊ†º‰ΩçÁΩÆÊòØÂê¶ÂèØËææ"""
        x, y = grid_pos
        if not (0 <= x < self.mapper.grid_size and 0 <= y < self.mapper.grid_size):
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶ÊòØÈöúÁ¢çÁâ©
        if self.mapper.global_map[y, x] == 2:
            return False
        
        # Ê£ÄÊü•ÂØπÂ∫îÁöÑ‰∏ñÁïåÂùêÊ†áÊòØÂê¶ÂÆâÂÖ®
        world_pos = self.mapper.grid_to_world(grid_pos)
        return self._is_position_accessible(world_pos)
    
    def _is_movement_safe(self, from_pos, to_pos, is_diagonal=False):
        """Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÂÆâÂÖ®ÔºàÂåÖÊã¨ÂØπËßíÁ∫øÁßªÂä®ÁöÑ‰∏•Ê†ºÊ£ÄÊü•Ôºâ"""
        # Âü∫Á°Ä‰ΩçÁΩÆÊ£ÄÊü•
        if not self._is_position_accessible(to_pos):
            return False
        
        # ‰ΩøÁî®maze_envÁöÑcan_move_toÊñπÊ≥ïËøõË°åÂü∫Á°ÄÈ™åËØÅ
        if not self.maze_env.can_move_to(from_pos, to_pos):
            return False
        
        # ÂØπËßíÁ∫øÁßªÂä®ÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ‰∏•Ê†ºÊ£ÄÊü•
        if is_diagonal:
            # Ê£ÄÊü•ÂØπËßíÁ∫øÁßªÂä®ÁöÑÂ§ö‰∏™‰∏≠Èó¥ÁÇπ
            steps = 5  # Â¢ûÂä†Ê£ÄÊü•ÁÇπÊï∞Èáè
            for i in range(1, steps):
                t = i / steps
                mid_x = from_pos[0] + t * (to_pos[0] - from_pos[0])
                mid_y = from_pos[1] + t * (to_pos[1] - from_pos[1])
                mid_pos = (mid_x, mid_y)
                
                if not self._is_position_accessible(mid_pos):
                    return False
            
            # Ê£ÄÊü•ÂØπËßíÁ∫øÁßªÂä®‰∏ç‰ºö"ÂàáËßí"Á©øÂ¢ô
            # ÂøÖÈ°ªËá≥Â∞ëÊúâ‰∏Ä‰∏™Áõ¥ËßíË∑ØÂæÑÂèØË°å
            corner1 = (from_pos[0], to_pos[1])
            corner2 = (to_pos[0], from_pos[1])
            
            corner1_safe = (self._is_position_accessible(corner1) and 
                           self.maze_env.can_move_to(from_pos, corner1) and
                           self.maze_env.can_move_to(corner1, to_pos))
            corner2_safe = (self._is_position_accessible(corner2) and 
                           self.maze_env.can_move_to(from_pos, corner2) and
                           self.maze_env.can_move_to(corner2, to_pos))
            
            if not (corner1_safe or corner2_safe):
                return False
            
            # È¢ùÂ§ñÁöÑÂ¢ôÂ£ÅË∑ùÁ¶ªÊ£ÄÊü• - ÂØπËßíÁ∫øË∑ØÂæÑ‰∏äÊØè‰∏™ÁÇπÈÉΩË¶ÅÊ£ÄÊü•
            for i in range(steps + 1):
                t = i / steps
                check_x = from_pos[0] + t * (to_pos[0] - from_pos[0])
                check_y = from_pos[1] + t * (to_pos[1] - from_pos[1])
                check_pos = (check_x, check_y)
                
                # Ê£ÄÊü•‰∏éÊâÄÊúâÂ¢ôÂ£ÅÁöÑË∑ùÁ¶ª
                min_wall_distance = 0.4  # Â§ßÂπÖÂ¢ûÂä†ÂÆâÂÖ®Ë∑ùÁ¶ªÔºåÈò≤Ê≠¢Á©øÂ¢ô
                for wall in self.maze_env.walls + self.maze_env.invisible_walls:
                    wall_dist = self._point_to_line_distance(check_pos, wall[0], wall[1])
                    if wall_dist < min_wall_distance:
                        return False
        else:
            # Áõ¥Á∫øÁßªÂä®‰πüË¶ÅÊ£ÄÊü•‰∏≠Èó¥ÁÇπ
            steps = 3
            for i in range(1, steps):
                t = i / steps
                mid_x = from_pos[0] + t * (to_pos[0] - from_pos[0])
                mid_y = from_pos[1] + t * (to_pos[1] - from_pos[1])
                mid_pos = (mid_x, mid_y)
                
                if not self._is_position_accessible(mid_pos):
                    return False
        
        return True
    
    def _find_nearest_accessible_position(self, target_grid):
        """ÂØªÊâæÊúÄËøëÁöÑÂèØËææ‰ΩçÁΩÆ"""
        for radius in range(1, 20):
            for dx in range(-radius, radius + 1):
                for dy in range(-radius, radius + 1):
                    if abs(dx) == radius or abs(dy) == radius:
                        candidate = (target_grid[0] + dx, target_grid[1] + dy)
                        if self._is_grid_position_accessible(candidate):
                            candidate_world = self.mapper.grid_to_world(candidate)
                            if (0.3 <= candidate_world[0] <= self.maze_env.size - 0.3 and
                                0.3 <= candidate_world[1] <= self.maze_env.size - 0.3):
                                return candidate
        return None
    
    def _reconstruct_optimal_path(self, came_from, current, start_pos, goal_pos):
        """ÈáçÊûÑÊúÄ‰ºòË∑ØÂæÑ"""
        path = [goal_pos]  # ‰ªéÁõÆÊ†áÁÇπÂºÄÂßã
        
        while current in came_from:
            world_pos = self.mapper.grid_to_world(current)
            path.append(world_pos)
            current = came_from[current]
        
        path.append(start_pos)
        path.reverse()
        return path
    
    def _smooth_optimal_path(self, path):
        """‰ºòÂåñË∑ØÂæÑÔºàÁßªÈô§‰∏çÂøÖË¶ÅÁöÑ‰∏≠Èó¥ÁÇπÔºâ- ‰∏•Ê†ºÈò≤Á©øÂ¢ôÁâàÊú¨"""
        if len(path) <= 2:
            return path
        
        smoothed_path = [path[0]]
        i = 0
        
        while i < len(path) - 1:
            # Â∞ùËØïÁõ¥Á∫øËøûÊé•Âà∞Â∞ΩÂèØËÉΩËøúÁöÑÁÇπÔºå‰ΩÜË¶Å‰∏•Ê†ºÈ™åËØÅ
            j = len(path) - 1
            found_direct = False
            
            while j > i + 1:
                is_diagonal = self._is_diagonal_movement(smoothed_path[-1], path[j])
                
                # ÂØπ‰∫éËæÉÈïøÁöÑË∑≥Ë∑ÉÔºåËøõË°åÈ¢ùÂ§ñÈ™åËØÅ
                if self._is_movement_safe_detailed(smoothed_path[-1], path[j], is_diagonal):
                    smoothed_path.append(path[j])
                    i = j
                    found_direct = True
                    break
                j -= 1
            
            if not found_direct:
                smoothed_path.append(path[i + 1])
                i += 1
        
        return smoothed_path
    
    def _is_movement_safe_detailed(self, from_pos, to_pos, is_diagonal):
        """ËØ¶ÁªÜÁöÑÁßªÂä®ÂÆâÂÖ®Ê£ÄÊü•ÔºàÁî®‰∫éË∑ØÂæÑÂπ≥ÊªëÂåñÔºâ"""
        # ËÆ°ÁÆóË∑ùÁ¶ª
        distance = math.sqrt((to_pos[0] - from_pos[0])**2 + (to_pos[1] - from_pos[1])**2)
        
        # ÂØπ‰∫éËæÉÈïøÁöÑÁßªÂä®Ôºå‰ΩøÁî®Êõ¥Â§öÊ£ÄÊü•ÁÇπ
        if distance > 1.0:
            steps = max(10, int(distance * 10))  # Ëá≥Â∞ë10‰∏™Ê£ÄÊü•ÁÇπ
        else:
            steps = 5
        
        # Ê£ÄÊü•Ë∑ØÂæÑ‰∏äÁöÑÊØè‰∏™ÁÇπ
        for i in range(steps + 1):
            t = i / steps
            check_x = from_pos[0] + t * (to_pos[0] - from_pos[0])
            check_y = from_pos[1] + t * (to_pos[1] - from_pos[1])
            check_pos = (check_x, check_y)
            
            # Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÂèØËææ
            if not self._is_position_accessible(check_pos):
                return False
            
            # Ê£ÄÊü•‰∏éÂ¢ôÂ£ÅÁöÑË∑ùÁ¶ª
            min_wall_distance = 0.4  # Êõ¥Â§ßÁöÑÂÆâÂÖ®Ë∑ùÁ¶ªÔºå‰∏éÂÖ∂‰ªñÊ£ÄÊü•‰∏ÄËá¥
            for wall in self.maze_env.walls + self.maze_env.invisible_walls:
                wall_dist = self._point_to_line_distance(check_pos, wall[0], wall[1])
                if wall_dist < min_wall_distance:
                    return False
        
        # Â¶ÇÊûúÊòØÂØπËßíÁ∫øÁßªÂä®ÔºåËøòË¶ÅÊ£ÄÊü•Áõ¥ËßíË∑ØÂæÑ
        if is_diagonal:
            corner1 = (from_pos[0], to_pos[1])
            corner2 = (to_pos[0], from_pos[1])
            
            corner1_safe = (self._is_position_accessible(corner1) and 
                           self.maze_env.can_move_to(from_pos, corner1) and
                           self.maze_env.can_move_to(corner1, to_pos))
            corner2_safe = (self._is_position_accessible(corner2) and 
                           self.maze_env.can_move_to(from_pos, corner2) and
                           self.maze_env.can_move_to(corner2, to_pos))
            
            if not (corner1_safe or corner2_safe):
                return False
        
        # ÊúÄÁªà‰ΩøÁî®maze_envÈ™åËØÅ
        return self.maze_env.can_move_to(from_pos, to_pos)
    
    def _is_diagonal_movement(self, from_pos, to_pos):
        """Âà§Êñ≠ÊòØÂê¶‰∏∫ÂØπËßíÁ∫øÁßªÂä®"""
        dx = abs(to_pos[0] - from_pos[0])
        dy = abs(to_pos[1] - from_pos[1])
        return dx > 0.01 and dy > 0.01
    
    def _point_to_line_distance(self, point, line_start, line_end):
        """ËÆ°ÁÆóÁÇπÂà∞Á∫øÊÆµÁöÑË∑ùÁ¶ª"""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        line_len = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        if line_len == 0:
            return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)
        
        t = max(0, min(1, ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / (line_len**2)))
        
        proj_x = x1 + t * (x2 - x1)
        proj_y = y1 + t * (y2 - y1)
        
        return math.sqrt((x0 - proj_x)**2 + (y0 - proj_y)**2)
    
    def _heuristic(self, a, b):
        """A*ÂêØÂèëÂºèÂáΩÊï∞ÔºàÂÖ´ÊñπÂêëÊ¨ßÂá†ÈáåÂæóË∑ùÁ¶ªÔºâ"""
        dx = abs(a[0] - b[0])
        dy = abs(a[1] - b[1])
        
        # ÂØπËßíÁ∫øË∑ùÁ¶ª‰ºòÂåñÁöÑÂêØÂèëÂºè
        # ÂØπËßíÁ∫øÊ≠•Êï∞ = min(dx, dy)ÔºåÁõ¥Á∫øÊ≠•Êï∞ = |dx - dy|
        diagonal_steps = min(dx, dy)
        straight_steps = abs(dx - dy)
        
        return diagonal_steps * 1.414 + straight_steps * 1.0

class LaserSimulator:
    """ÊøÄÂÖâÈõ∑ËææÊ®°ÊãüÂô®Ôºà‰ºòÂåñÁâàÔºâ"""
    
    def __init__(self, maze_env, max_range=8.0):
        self.maze_env = maze_env
        self.max_range = max_range
    
    def scan(self, robot_pos):
        """ÊâßË°å360Â∫¶ÊøÄÂÖâÊâ´Êèè"""
        x, y = robot_pos
        scan_points = []
        obstacle_points = []
        scan_ranges = []
        scan_angles = []
        
        # È´òÈÄüÊ®°ÂºèÔºö360Â∫¶Êâ´ÊèèÔºåÊØè4Â∫¶‰∏Ä‰∏™Â∞ÑÁ∫øÔºàÂáèÂ∞ëËÆ°ÁÆóÈáèÔºâ
        for angle_deg in range(0, 360, 4):
            angle_rad = math.radians(angle_deg)
            ray_direction = (math.cos(angle_rad), math.sin(angle_rad))
            
            # ÊâæÂà∞ÊúÄËøëÁöÑÂ¢ôÁ¢∞ÊíûÁÇπ
            closest_collision = None
            min_distance = self.max_range
            
            # Ê£ÄÊü•ÂÜÖÈÉ®Â¢ôÂ£Å
            for wall in self.maze_env.walls:
                collision = self.ray_wall_intersection(robot_pos, ray_direction, wall[0], wall[1])
                if collision and collision[2] < min_distance:
                    closest_collision = collision
                    min_distance = collision[2]
            
            # Ê£ÄÊü•ÈöêÂΩ¢Â¢ô
            for wall in self.maze_env.invisible_walls:
                collision = self.ray_wall_intersection(robot_pos, ray_direction, wall[0], wall[1])
                if collision and collision[2] < min_distance:
                    closest_collision = collision
                    min_distance = collision[2]
            
            # Ê£ÄÊü•ËæπÁïåÔºàÂè™ÊúâÊé•ËøëÊó∂ÊâçÊ£ÄÊµãÔºâ
            boundary_collision = self.ray_boundary_intersection(robot_pos, ray_direction)
            is_boundary_hit = False
            if boundary_collision and boundary_collision[2] < min_distance:
                closest_collision = boundary_collision
                min_distance = boundary_collision[2]
                # Ê†áËÆ∞ËøôÊòØÂ§ñÊ°ÜÁ¢∞ÊíûÔºå‰∏çÂ∫îÂÜôÂÖ•ÈöúÁ¢çÁÇπ
                is_boundary_hit = True
            
            if closest_collision:
                collision_x, collision_y, distance = closest_collision
                
                # Âè™ÊúâÁ¢∞Âà∞ÁúüÂÆûÂ¢ô‰ΩìÊàñÈöêÂΩ¢Â¢ôÊó∂ÊâçËÆ∞ÂΩï‰∏∫ÈöúÁ¢çÁÇπÔºåÂ§ñÊ°ÜÁ¢∞Êíû‰∏çËÆ∞ÂΩï
                if not is_boundary_hit:
                    obstacle_points.append((collision_x, collision_y))
                
                scan_ranges.append(distance)
                scan_angles.append(angle_deg)
                
                # Âú®Â∞ÑÁ∫øË∑ØÂæÑ‰∏äÊ∑ªÂä†Ëá™Áî±Á©∫Èó¥ÁÇπ
                for d in np.arange(0.2, distance, 0.2):
                    free_x = x + d * math.cos(angle_rad)
                    free_y = y + d * math.sin(angle_rad)
                    scan_points.append((free_x, free_y))
            else:
                scan_ranges.append(self.max_range)
                scan_angles.append(angle_deg)
                for d in np.arange(0.2, self.max_range, 0.2):
                    free_x = x + d * math.cos(angle_rad)
                    free_y = y + d * math.sin(angle_rad)
                    scan_points.append((free_x, free_y))
        
        # Ê£ÄÊü•Âá∫Âè£Ôºà180Â∫¶ËøûÁª≠ÂºÄÊîæÂå∫ÂüüÔºâ
        exit_found = self.detect_exit_from_scan(robot_pos, scan_ranges, scan_angles)
        
        return scan_points, obstacle_points, scan_ranges, scan_angles, exit_found
    
    def ray_wall_intersection(self, ray_start, ray_direction, wall_start, wall_end):
        """ËÆ°ÁÆóÂ∞ÑÁ∫ø‰∏éÂ¢ôÂ£ÅÁöÑ‰∫§ÁÇπ"""
        x1, y1 = ray_start
        dx, dy = ray_direction
        x3, y3 = wall_start
        x4, y4 = wall_end
        
        denom = (x4 - x3) * dy - (y4 - y3) * dx
        if abs(denom) < 1e-10:
            return None
        
        t = ((y3 - y1) * dx - (x3 - x1) * dy) / denom
        u = ((y3 - y1) * (x4 - x3) - (x3 - x1) * (y4 - y3)) / denom
        
        if 0 <= t <= 1 and u >= 0:
            intersection_x = x3 + t * (x4 - x3)
            intersection_y = y3 + t * (y4 - y3)
            distance = math.sqrt((intersection_x - x1)**2 + (intersection_y - y1)**2)
            return (intersection_x, intersection_y, distance)
        
        return None
    
    def ray_boundary_intersection(self, ray_start, ray_direction):
        """ËÆ°ÁÆóÂ∞ÑÁ∫ø‰∏éÊâ©Â±ïËæπÁïåÁöÑ‰∫§ÁÇπÔºàÂèØÊâ´ÊèèÂå∫ÂüüËæπÁïåÂú®-2Âíåmax+2Ôºâ"""
        robot_x, robot_y = ray_start
        
        # Êâ©Â±ïËæπÁïåÔºàÊøÄÂÖâÂèØ‰ª•Êâ´ÊèèÂà∞ÁöÑËæπÁïåÔºâ
        extended_boundaries = [
            # Â§ñËæπÁïåÔºà-2Âíåmax+2Â§ÑÁöÑËæπÁïåÔºâ
            ((-2, -2), (-2, self.maze_env.size + 2)),  # Â∑¶Â§ñËæπÁïå
            ((self.maze_env.size + 2, -2), (self.maze_env.size + 2, self.maze_env.size + 2)),  # Âè≥Â§ñËæπÁïå
            ((-2, -2), (self.maze_env.size + 2, -2)),  # ‰∏ãÂ§ñËæπÁïå
            ((-2, self.maze_env.size + 2), (self.maze_env.size + 2, self.maze_env.size + 2)),  # ‰∏äÂ§ñËæπÁïå
        ]
        
        # **Ê≥®ÊÑè**Ôºö‰∏çÂÜçÊääËø∑ÂÆ´Êú¨Ë∫´ÁöÑ 0/size ËæπÁïåÂä†ÂÖ•Á¢∞ÊíûÊ£ÄÊµãÔºåÂè™‰øùÁïô -2 ‰∏é size+2 ÁöÑÂ§ñÊ°ÜÔºå
        # ÈÅøÂÖçÂú® SLAM Âú∞Âõæ‰∏≠Âá∫Áé∞Èù†ËøëÁúüÂÆûËæπÁïå (x=0 Êàñ y=0 Á≠â) ÁöÑ‰º™ÈöúÁ¢çÊù°Á∫π„ÄÇ
        
        closest_intersection = None
        min_distance = self.max_range
        
        for boundary in extended_boundaries:
            intersection = self.ray_wall_intersection(ray_start, ray_direction, boundary[0], boundary[1])
            if intersection and intersection[2] < min_distance:
                closest_intersection = intersection
                min_distance = intersection[2]
        
        return closest_intersection
    
    def detect_exit_from_scan(self, robot_pos, scan_ranges, scan_angles):
        """ÁÆÄÂåñÁâàÂá∫Âè£Ê£ÄÊµãÔºöÂü∫‰∫éËæπÁïåÊñπÂêëÁöÑÂ§ßÈáèÊøÄÂÖâÂ∞ÑÁ∫øÊú™ÂëΩ‰∏≠ÂÜÖÂ£ÅËÄåÁõ¥Êé•ÊâìÂà∞Â§ñÊ°Ü„ÄÇ"""

        # ÊúÄÂ∞ëÈúÄË¶Å‰∏ÄÂÆöÊï∞ÈáèÊâ´ÊèèÊï∞ÊçÆ
        if len(scan_ranges) < 45:
            return False

        x, y = robot_pos
        size = self.maze_env.size

        # Ë∑ùÁ¶ªÂõõÊù°‰∏ªËæπÁïåÁöÑË∑ùÁ¶ª
        dists = {
            'left': x,
            'right': size - x,
            'bottom': y,
            'top': size - y
        }

        # ÊâæÂà∞ÊúÄËøëËæπÁïåÔºåÂπ∂Ë¶ÅÊ±Ç <1mÔºåÂê¶Âàô‰∏çËÆ§‰∏∫Âú®Âá∫Âè£ÈôÑËøë
        side, d_to_boundary = min(dists.items(), key=lambda kv: kv[1])

        # ÈúÄËøúÁ¶ªÂÖ•Âè£ÔºàÈÅøÂÖçÊääÂÖ•Âè£ËØØÂà§‰∏∫Âá∫Âè£Ôºâ
        sx, sy = self.maze_env.start_pos
        if math.hypot(x - sx, y - sy) < 3.0:  # Ë∑ùÂÖ•Âè£ <3m Áõ¥Êé•ËøîÂõû
            return False

        # ÂøÖÈ°ªÈùûÂ∏∏Èù†ËøëËæπÁïå <0.5m
        if d_to_boundary > 0.5:
            return False

        # ËØ•ËæπÁïåÂØπÂ∫îÁöÑ‰∏≠ÂøÉËßíÔºàÂ∫¶Ôºâ
        side_angle = {
            'right': 0,
            'top': 90,
            'left': 180,
            'bottom': 270
        }[side]

        # Êî∂ÈõÜ ¬±25¬∞ ÂÜÖÁöÑÂ∞ÑÁ∫ø
        candidate = []
        for rng, ang in zip(scan_ranges, scan_angles):
            diff = abs((ang - side_angle + 180) % 360 - 180)
            if diff <= 25:
                candidate.append((rng, ang))

        if len(candidate) < 8:
            return False

        # ÁêÜËÆ∫‰∏äÂú®ËØ•ÊñπÂêëÂ∫îÁ¢∞Âà∞ËæπÁïåÁöÑË∑ùÁ¶ª
        expected = d_to_boundary

        # Âà§ÂÆöÂ§öÂ∞ëÂ∞ÑÁ∫øÁõ¥Êé•ÂëΩ‰∏≠Â§ñÊ°ÜÔºàrange ‰∏éÂ§ñÊ°Ü‰∫§ÁÇπË∑ùÁ¶ªÂá†‰πé‰∏ÄËá¥Ôºâ
        boundary_hits = 0
        for rng, ang in candidate:
            ang_rad = math.radians(ang)
            ray_dir = (math.cos(ang_rad), math.sin(ang_rad))
            bc = self.ray_boundary_intersection(robot_pos, ray_dir)
            if bc and abs(bc[2] - rng) < 0.05:
                boundary_hits += 1

        # Ëã• ‚â•80% ÁöÑÂ∞ÑÁ∫øÁõ¥Êé•Âà∞Â§ñÊ°ÜÔºåÂàôËÆ§‰∏∫ÊúâÂá∫Âè£Áº∫Âè£
        if boundary_hits / len(candidate) < 0.8:
            return False

        # ËÆ∞ÂΩïÂπ∂ËøîÂõû
        if self.maze_env.add_discovered_exit(robot_pos):
            print(f"üéØ NEW EXIT discovered at {side} boundary (simple gap)!" )

        self.maze_env.mark_exit_reached(robot_pos)
        self.maze_env.exit_detected = True
        self.maze_env.exit_position = robot_pos

        print(f"   Robot position: ({x:.2f}, {y:.2f})")
        print(f"   Boundary hits in ¬±25¬∞ sector: {boundary_hits}/{len(candidate)} (expected={expected:.2f}m)")
        return True

class SmartMazeSLAMVisualizer:
    """Êô∫ËÉΩÂèØËßÜÂåñÂô®"""
    
    def __init__(self, maze_env, global_mapper, num_robots):
        self.maze_env = maze_env
        self.global_mapper = global_mapper
        self.num_robots = num_robots
        
        # ÂàõÂª∫4Èù¢ÊùøÊòæÁ§∫
        self.fig, self.axes = plt.subplots(2, 2, figsize=(20, 12))
        self.ax_true = self.axes[0, 0]      # ÁúüÂÆûËø∑ÂÆ´
        self.ax_global = self.axes[0, 1]    # ÂÖ®Â±ÄSLAMÂú∞Âõæ
        self.ax_frontiers = self.axes[1, 0] # ÂâçÊ≤øÊé¢Á¥¢Âõæ
        self.ax_status = self.axes[1, 1]    # Áä∂ÊÄÅ‰ø°ÊÅØ
        
        # Êú∫Âô®‰∫∫È¢úËâ≤
        self.robot_colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']
        
        # ÂΩìÂâçÊâ´ÊèèÊï∞ÊçÆ
        self.current_scan_data = {}
        
        plt.ion()
    
    def update_scan_data(self, robot_id, robot_pos, scan_points, obstacle_points, scan_ranges, scan_angles):
        """Êõ¥Êñ∞Êâ´ÊèèÊï∞ÊçÆ"""
        self.current_scan_data[robot_id] = {
            'pos': robot_pos,
            'scan_points': scan_points,
            'obstacle_points': obstacle_points,
            'scan_ranges': scan_ranges,
            'scan_angles': scan_angles
        }
    
    def draw_true_maze(self, robot_positions, robot_targets):
        """ÁªòÂà∂ÁúüÂÆûËø∑ÂÆ´"""
        ax = self.ax_true
        ax.clear()
        
        # ÁªòÂà∂Êâ©Â±ïÂå∫ÂüüÁöÑÁÅ∞Ëâ≤ËÉåÊôØÔºà‰∏çÂèØÈÄöË°å‰ΩÜÂèØÊâ´ÊèèÁöÑÂå∫ÂüüÔºâ
        # Â∑¶ËæπÂå∫Âüü (-2Âà∞0)
        ax.fill_between([-2, 0], -2, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        # Âè≥ËæπÂå∫Âüü (maxÂà∞max+2)
        ax.fill_between([self.maze_env.size, self.maze_env.size + 2], -2, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        # ‰∏ãËæπÂå∫Âüü (0Âà∞max, -2Âà∞0)
        ax.fill_between([0, self.maze_env.size], -2, 0, color='lightgray', alpha=0.3, zorder=0)
        # ‰∏äËæπÂå∫Âüü (0Âà∞max, maxÂà∞max+2)
        ax.fill_between([0, self.maze_env.size], self.maze_env.size, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        
        # ÁªòÂà∂Â¢ôÂ£Å
        for wall in self.maze_env.walls:
            (x1, y1), (x2, y2) = wall
            ax.plot([x1, x2], [y1, y2], 'k-', linewidth=3)
        
        # ÁªòÂà∂Ëµ∑Âßã‰ΩçÁΩÆ
        start_x, start_y = self.maze_env.start_pos
        ax.plot(start_x, start_y, 'go', markersize=10, label='Start')
        
        # ÁªòÂà∂Â∑≤ÂèëÁé∞ÁöÑÂá∫Âè£
        for i, exit_pos in enumerate(self.maze_env.discovered_exits):
            exit_x, exit_y = exit_pos
            ax.plot(exit_x, exit_y, 'rs', markersize=10, label='Discovered Exit' if i == 0 else '')
            # Ê∑ªÂä†Âá∫Âè£Ê†áËØÜ
            ax.text(exit_x + 0.1, exit_y + 0.1, f'Exit{i+1}', fontsize=8, color='red')
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫Âà∞ËææÂá∫Âè£Êó∂ÁöÑ‰ΩçÁΩÆÊ†áËÆ∞ÔºàÁ∫¢Ëâ≤Â∞èÂúàÔºâ
        for i, reached_pos in enumerate(self.maze_env.reached_exit_positions):
            reached_x, reached_y = reached_pos
            ax.plot(reached_x, reached_y, 'ro', markersize=12, markerfacecolor='red', 
                   markeredgecolor='darkred', markeredgewidth=2, alpha=0.8,
                   label='Exit Reached' if i == 0 else '')
            # Ê∑ªÂä†Âà∞ËææÊ†áËØÜ
            ax.text(reached_x + 0.15, reached_y + 0.15, f'REACHED', fontsize=7, 
                   color='darkred', fontweight='bold')
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫ÂíåË∑ØÂæÑ
        for i, (robot_id, pos) in enumerate(robot_positions.items()):
            color = self.robot_colors[i % len(self.robot_colors)]
            
            # ÁªòÂà∂Êú∫Âô®‰∫∫
            ax.plot(pos[0], pos[1], 'o', color=color, markersize=8, label=robot_id)
            
            # ÁªòÂà∂Ë∑ØÂæÑ
            if robot_id in self.global_mapper.robot_paths:
                path = self.global_mapper.robot_paths[robot_id]
                if len(path) > 1:
                    path_x = [p[0] for p in path]
                    path_y = [p[1] for p in path]
                    ax.plot(path_x, path_y, '--', color=color, alpha=0.5, linewidth=1)
            
            # ÁªòÂà∂ÁõÆÊ†áÁÇπ
            if robot_id in robot_targets and robot_targets[robot_id]:
                target = robot_targets[robot_id]
                ax.plot(target[0], target[1], 'x', color=color, markersize=12, markeredgewidth=3)
                # ÁªòÂà∂ÁõÆÊ†áËøûÁ∫ø
                ax.plot([pos[0], target[0]], [pos[1], target[1]], ':', color=color, alpha=0.7)
        
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.legend(loc='upper right', fontsize=8, ncol=2)
        ax.set_title("True Maze + Robot Targets", fontsize=14)
    
    def draw_global_slam_map(self):
        """ÁªòÂà∂ÂÖ®Â±ÄSLAMÂú∞Âõæ"""
        ax = self.ax_global
        ax.clear()
        
        # ÊâÄÊúâÊâ©Â±ïÂå∫ÂüüÈÉΩ‰∏çÁªòÂà∂ËÉåÊôØÔºåËÆ©ÂÖ∂‰øùÊåÅ‰∏éÊú™Êâ´ÊèèÂå∫ÂüüÁõ∏ÂêåÁöÑÈ¢úËâ≤
        
        # ÂàõÂª∫È¢úËâ≤Âú∞Âõæ
        cmap = colors.ListedColormap(['lightgray', 'white', 'black'])
        ax.imshow(self.global_mapper.global_map, cmap=cmap, origin='lower', 
                 extent=[-2, self.global_mapper.display_size-2, -2, self.global_mapper.display_size-2], alpha=0.8)
        
        # ÁªòÂà∂ÊâÄÊúâÊú∫Âô®‰∫∫‰ΩçÁΩÆ
        for i, (robot_id, path) in enumerate(self.global_mapper.robot_paths.items()):
            if path:
                color = self.robot_colors[i % len(self.robot_colors)]
                current_pos = path[-1]
                ax.plot(current_pos[0], current_pos[1], 'o', color=color, markersize=6)
        
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.set_title("Global SLAM Map", fontsize=14)
    
    def draw_frontier_exploration(self):
        """ÁªòÂà∂ÂâçÊ≤øÊé¢Á¥¢Âõæ"""
        ax = self.ax_frontiers
        ax.clear()
        
        # ÊâÄÊúâÊâ©Â±ïÂå∫ÂüüÈÉΩ‰∏çÁªòÂà∂ËÉåÊôØÔºåËÆ©ÂÖ∂‰øùÊåÅ‰∏éÊú™Êâ´ÊèèÂå∫ÂüüÁõ∏ÂêåÁöÑÈ¢úËâ≤
        
        # ÁªòÂà∂ÂÖ®Â±ÄÂú∞ÂõæËÉåÊôØ
        cmap = colors.ListedColormap(['lightgray', 'white', 'black'])
        ax.imshow(self.global_mapper.global_map, cmap=cmap, origin='lower', 
                 extent=[-2, self.global_mapper.display_size-2, -2, self.global_mapper.display_size-2], alpha=0.7)
        
        # ÁªòÂà∂ÂâçÊ≤øÁÇπ
        if self.global_mapper.frontiers:
            frontier_x = [f[0] for f in self.global_mapper.frontiers]
            frontier_y = [f[1] for f in self.global_mapper.frontiers]
            ax.plot(frontier_x, frontier_y, 'r*', markersize=8, alpha=0.8, label=f'Frontiers ({len(self.global_mapper.frontiers)})')
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫‰ΩçÁΩÆ
        for i, (robot_id, path) in enumerate(self.global_mapper.robot_paths.items()):
            if path:
                color = self.robot_colors[i % len(self.robot_colors)]
                current_pos = path[-1]
                ax.plot(current_pos[0], current_pos[1], 'o', color=color, markersize=8)
        
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.legend()
        ax.set_title("Frontier Exploration", fontsize=14)
    
    def draw_status_info(self, robots_info, exploration_stats):
        """ÁªòÂà∂Áä∂ÊÄÅ‰ø°ÊÅØ"""
        ax = self.ax_status
        ax.clear()
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 12)
        
        # ÊòæÁ§∫Êú∫Âô®‰∫∫Áä∂ÊÄÅÔºàÂàÜ‰∏§ÂàóÔºâ
        left_robots = list(robots_info.items())[:3]
        right_robots = list(robots_info.items())[3:]
        
        # Â∑¶Âàó
        y_pos = 11
        for robot_id, info in left_robots:
            color = self.robot_colors[list(robots_info.keys()).index(robot_id) % len(self.robot_colors)]
            
            status_text = f"{robot_id}:\n"
            status_text += f"  Pos: ({info['pos'][0]:.1f}, {info['pos'][1]:.1f})\n"
            status_text += f"  Steps: {info['steps']}\n"
            status_text += f"  Status: {info['status']}\n"
            if info['target']:
                status_text += f"  Target: ({info['target'][0]:.1f}, {info['target'][1]:.1f})"
            
            ax.text(0.5, y_pos, status_text, fontsize=9, color=color, 
                   verticalalignment='top', fontweight='bold')
            y_pos -= 3.5
        
        # Âè≥Âàó
        y_pos = 11
        for robot_id, info in right_robots:
            color = self.robot_colors[list(robots_info.keys()).index(robot_id) % len(self.robot_colors)]
            
            status_text = f"{robot_id}:\n"
            status_text += f"  Pos: ({info['pos'][0]:.1f}, {info['pos'][1]:.1f})\n"
            status_text += f"  Steps: {info['steps']}\n"
            status_text += f"  Status: {info['status']}\n"
            if info['target']:
                status_text += f"  Target: ({info['target'][0]:.1f}, {info['target'][1]:.1f})"
            
            ax.text(5.5, y_pos, status_text, fontsize=9, color=color, 
                   verticalalignment='top', fontweight='bold')
            y_pos -= 3.5
        
        # ÂÖ®Â±ÄÁªüËÆ°
        stats_text = f"Exploration Progress:\n"
        stats_text += f"Frontiers: {exploration_stats['frontiers']}\n"
        stats_text += f"Coverage: {exploration_stats['coverage']:.1f}%\n"
        stats_text += f"Active Robots: {exploration_stats['active_robots']}/{self.num_robots}"
        
        ax.text(5, 1.5, stats_text, fontsize=11, fontweight='bold', 
               horizontalalignment='center', verticalalignment='center',
               bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
        
        ax.set_title("Robot Status & Progress", fontsize=14)
        ax.axis('off')
    
    def update_display(self, robot_positions, robot_targets, robots_info, exploration_stats):
        """Êõ¥Êñ∞ÊòæÁ§∫"""
        self.draw_true_maze(robot_positions, robot_targets)
        self.draw_global_slam_map()
        self.draw_frontier_exploration()
        self.draw_status_info(robots_info, exploration_stats)
        plt.tight_layout()
        plt.subplots_adjust(top=0.95, bottom=0.05, left=0.05, right=0.97, hspace=0.2, wspace=0.2)
        plt.pause(0.001)

class SingleRobotVisualizer:
    """ÂçïÊú∫Âô®‰∫∫ÂèØËßÜÂåñÂô®ÔºàÁÆÄÂåñÁâàÔºâ"""
    
    def __init__(self, maze_env, global_mapper, robot):
        self.maze_env = maze_env
        self.global_mapper = global_mapper
        self.robot = robot
        
        # ÂàõÂª∫1x3Èù¢ÊùøÊòæÁ§∫
        self.fig, self.axes = plt.subplots(1, 3, figsize=(18, 6))
        self.ax_true = self.axes[0]      # ÁúüÂÆûËø∑ÂÆ´ + Êú∫Âô®‰∫∫
        self.ax_slam = self.axes[1]      # SLAMÂú∞Âõæ
        self.ax_radar = self.axes[2]     # Èõ∑ËææÊ®°ÊãüÂõæ
        
        # Â≠òÂÇ®ÊúÄÊñ∞ÁöÑÊâ´ÊèèÊï∞ÊçÆ
        self.latest_scan_points = []
        self.latest_obstacle_points = []
        self.latest_scan_ranges = []
        self.latest_scan_angles = []
        
        # ÊúÄÁü≠Ë∑ØÂæÑ
        self.shortest_path = None
        
        plt.ion()
    
    def update_scan_data(self, scan_points, obstacle_points, scan_ranges, scan_angles):
        """Êõ¥Êñ∞Êâ´ÊèèÊï∞ÊçÆ"""
        self.latest_scan_points = scan_points
        self.latest_obstacle_points = obstacle_points  
        self.latest_scan_ranges = scan_ranges
        self.latest_scan_angles = scan_angles
    
    def set_shortest_path(self, shortest_path):
        """ËÆæÁΩÆÊúÄÁü≠Ë∑ØÂæÑ"""
        self.shortest_path = shortest_path
    
    def update_display(self):
        """Êõ¥Êñ∞ÊòæÁ§∫"""
        self.draw_true_maze()
        self.draw_slam_map()
        self.draw_radar_simulation()
        
        # ÊòæÁ§∫Áä∂ÊÄÅ‰ø°ÊÅØ
        status_text = f"Robot: {self.robot.robot_id}\n"
        status_text += f"Position: ({self.robot.position[0]:.2f}, {self.robot.position[1]:.2f})\n"
        status_text += f"Steps: {self.robot.steps}\n"
        status_text += f"Status: {self.robot.status}\n"
        status_text += f"No Move Count: {self.robot.no_move_counter}/3\n"
        status_text += f"Frontiers: {len(self.global_mapper.frontiers)}\n"
        status_text += f"Coverage: {self._calculate_coverage():.1f}%\n"
        status_text += f"Discovered Exits: {len(self.maze_env.discovered_exits)}\n"
        status_text += f"Exit Reached: {len(self.maze_env.reached_exit_positions)}\n"
        
        # ÊòæÁ§∫ÊúÄÁü≠Ë∑ØÂæÑÁä∂ÊÄÅ
        if self.shortest_path:
            path_length = 0
            diagonal_count = 0
            for i in range(len(self.shortest_path) - 1):
                p1 = self.shortest_path[i]
                p2 = self.shortest_path[i + 1]
                segment_length = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                path_length += segment_length
                # ÁªüËÆ°ÂØπËßíÁ∫øÊÆµ
                dx = abs(p2[0] - p1[0])
                dy = abs(p2[1] - p1[1])
                if dx > 0.01 and dy > 0.01:
                    diagonal_count += 1
            status_text += f"Optimal Path: {path_length:.3f} units\n"
            status_text += f"Diagonal Segments: {diagonal_count}\n"
        
        # ÊòæÁ§∫Êé¢Á¥¢Áä∂ÊÄÅ
        if len(self.maze_env.reached_exit_positions) > 0:
            status_text += f"üî¥ EXIT REACHED! MARKED!"
            if self.shortest_path:
                status_text += f"\nüíö SHORTEST PATH SHOWN!"
        elif len(self.maze_env.discovered_exits) == 0:
            status_text += f"üîç EXPLORING FOR EXITS..."
        else:
            status_text += f"üéØ EXITS FOUND!"
        
        self.fig.suptitle(status_text, fontsize=11, y=0.98)
        
        plt.tight_layout()
        plt.subplots_adjust(top=0.90, bottom=0.10, left=0.05, right=0.98, wspace=0.25)
        plt.pause(0.001)  # ÊûÅÂø´ÁöÑÊõ¥Êñ∞È¢ëÁéá
    
    def draw_true_maze(self):
        """ÁªòÂà∂ÁúüÂÆûËø∑ÂÆ´"""
        ax = self.ax_true
        ax.clear()
        
        # ÁªòÂà∂Êâ©Â±ïÂå∫ÂüüÁöÑÁÅ∞Ëâ≤ËÉåÊôØÔºà‰∏çÂèØÈÄöË°å‰ΩÜÂèØÊâ´ÊèèÁöÑÂå∫ÂüüÔºâ
        # Â∑¶ËæπÂå∫Âüü (-2Âà∞0)
        ax.fill_between([-2, 0], -2, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        # Âè≥ËæπÂå∫Âüü (maxÂà∞max+2)
        ax.fill_between([self.maze_env.size, self.maze_env.size + 2], -2, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        # ‰∏ãËæπÂå∫Âüü (0Âà∞max, -2Âà∞0)
        ax.fill_between([0, self.maze_env.size], -2, 0, color='lightgray', alpha=0.3, zorder=0)
        # ‰∏äËæπÂå∫Âüü (0Âà∞max, maxÂà∞max+2)
        ax.fill_between([0, self.maze_env.size], self.maze_env.size, self.maze_env.size + 2, color='lightgray', alpha=0.3, zorder=0)
        
        # ÁªòÂà∂Â¢ôÂ£Å
        for wall in self.maze_env.walls:
            (x1, y1), (x2, y2) = wall
            ax.plot([x1, x2], [y1, y2], 'k-', linewidth=3)
        
        # ÁªòÂà∂Ëµ∑Âßã‰ΩçÁΩÆ
        start_x, start_y = self.maze_env.start_pos
        ax.plot(start_x, start_y, 'go', markersize=8, label='Start')
        
        # ÁªòÂà∂Â∑≤ÂèëÁé∞ÁöÑÂá∫Âè£
        for i, exit_pos in enumerate(self.maze_env.discovered_exits):
            exit_x, exit_y = exit_pos
            ax.plot(exit_x, exit_y, 'rs', markersize=8, label='Discovered Exit' if i == 0 else '')
            # Ê∑ªÂä†Âá∫Âè£Ê†áËØÜ
            ax.text(exit_x + 0.1, exit_y + 0.1, f'Exit{i+1}', fontsize=8, color='red')
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫Âà∞ËææÂá∫Âè£Êó∂ÁöÑ‰ΩçÁΩÆÊ†áËÆ∞ÔºàÁ∫¢Ëâ≤Â∞èÂúàÔºâ
        for i, reached_pos in enumerate(self.maze_env.reached_exit_positions):
            reached_x, reached_y = reached_pos
            # ‰ΩøÁî®Á©∫ÂøÉÂúÜÂúàÔºåËÆ©ËìùËâ≤Êú∫Âô®‰∫∫ÁÇπ‰øùÊåÅÂèØËßÅ
            ax.plot(reached_x, reached_y, 'o', markersize=20, markerfacecolor='none',
                    markeredgecolor='red', markeredgewidth=3, alpha=0.9, zorder=10,
                    label='üî¥ EXIT REACHED' if i == 0 else '')
            # Ê∑ªÂä†ÊñáÊú¨Ê†áÁ≠æÔºàÊîæÂú®ÂúÜÂúàÂ§ñ‰æßÔºâ
            ax.text(reached_x + 0.25, reached_y + 0.25, 'EXIT', fontsize=9,
                    color='darkred', fontweight='bold', zorder=11)
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫Ë∑ØÂæÑ
        if self.robot.robot_id in self.global_mapper.robot_paths:
            path = self.global_mapper.robot_paths[self.robot.robot_id]
            if len(path) > 1:
                path_x = [p[0] for p in path]
                path_y = [p[1] for p in path]
                ax.plot(path_x, path_y, 'b--', alpha=0.6, linewidth=2, label='Path')
        
        # ÁªòÂà∂ÊúÄÁü≠Ë∑ØÂæÑÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if self.shortest_path and len(self.shortest_path) > 1:
            path_x = [p[0] for p in self.shortest_path]
            path_y = [p[1] for p in self.shortest_path]
            
            # ÁªòÂà∂‰∏ªË¶ÅË∑ØÂæÑÁ∫ø
            ax.plot(path_x, path_y, 'g-', linewidth=4, alpha=0.8, label='Optimal Path (8-dir)', zorder=5)
            
            # ÁªòÂà∂Ë∑ØÂæÑÊÆµÊ†áËÆ∞ÔºöÁõ¥Á∫øÊÆµÂíåÂØπËßíÁ∫øÊÆµÁî®‰∏çÂêåÊ†∑Âºè
            for i in range(len(self.shortest_path) - 1):
                p1 = self.shortest_path[i]
                p2 = self.shortest_path[i + 1]
                
                # Âà§Êñ≠ÊòØÂê¶‰∏∫ÂØπËßíÁ∫øÁßªÂä®
                dx = abs(p2[0] - p1[0])
                dy = abs(p2[1] - p1[1])
                is_diagonal = dx > 0.01 and dy > 0.01
                
                if is_diagonal:
                    # ÂØπËßíÁ∫øÊÆµÁî®ËôöÁ∫øÊ†áËÆ∞
                    ax.plot([p1[0], p2[0]], [p1[1], p2[1]], 'g--', 
                           linewidth=2, alpha=0.6, zorder=4)
                    # Âú®ÂØπËßíÁ∫øÊÆµ‰∏≠ÁÇπÊ∑ªÂä†Â∞èÂúÜÁÇπ
                    mid_x = (p1[0] + p2[0]) / 2
                    mid_y = (p1[1] + p2[1]) / 2
                    ax.plot(mid_x, mid_y, 'go', markersize=4, alpha=0.7, zorder=4)
            
            # Ê†áËÆ∞Ëµ∑ÁÇπÂíåÁªàÁÇπ
            ax.plot(path_x[0], path_y[0], 'go', markersize=12, markeredgewidth=2, 
                   markeredgecolor='darkgreen', label='Start', zorder=6)
            ax.plot(path_x[-1], path_y[-1], 'gs', markersize=12, markeredgewidth=2, 
                   markeredgecolor='darkgreen', label='End', zorder=6)
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫ÂΩìÂâç‰ΩçÁΩÆ
        ax.plot(self.robot.position[0], self.robot.position[1], 'bo', markersize=10, label='Robot')
        
        # ÁªòÂà∂ÁõÆÊ†áÁÇπ
        if self.robot.current_target:
            target = self.robot.current_target
            ax.plot(target[0], target[1], 'rx', markersize=12, markeredgewidth=3, label='Target')
            # ÁªòÂà∂ÁõÆÊ†áËøûÁ∫ø
            ax.plot([self.robot.position[0], target[0]], 
                   [self.robot.position[1], target[1]], 'r:', alpha=0.7)
        
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.legend(loc='upper right', fontsize=8)
        ax.set_title("True Maze + Robot", fontsize=12)
    
    def draw_slam_map(self):
        """ÁªòÂà∂SLAMÂú∞Âõæ"""
        ax = self.ax_slam
        ax.clear()
        
        # ÊâÄÊúâÊâ©Â±ïÂå∫ÂüüÈÉΩ‰∏çÁªòÂà∂ËÉåÊôØÔºåËÆ©ÂÖ∂‰øùÊåÅ‰∏éÊú™Êâ´ÊèèÂå∫ÂüüÁõ∏ÂêåÁöÑÈ¢úËâ≤
        
        # ÂàõÂª∫È¢úËâ≤Âú∞Âõæ
        cmap = colors.ListedColormap(['lightgray', 'white', 'black'])
        ax.imshow(self.global_mapper.global_map, cmap=cmap, origin='lower', 
                 extent=[-2, self.global_mapper.display_size-2, -2, self.global_mapper.display_size-2], alpha=0.8)
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫Âà∞ËææÂá∫Âè£Êó∂ÁöÑ‰ΩçÁΩÆÊ†áËÆ∞ÔºàÁ∫¢Ëâ≤Â∞èÂúàÔºâ
        for i, reached_pos in enumerate(self.maze_env.reached_exit_positions):
            reached_x, reached_y = reached_pos
            ax.plot(reached_x, reached_y, 'o', markersize=20, markerfacecolor='none',
                    markeredgecolor='red', markeredgewidth=3, alpha=0.9,
                    label='üî¥ EXIT REACHED' if i == 0 else '')
        
        # ÁªòÂà∂ÊúÄÁü≠Ë∑ØÂæÑÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if self.shortest_path and len(self.shortest_path) > 1:
            path_x = [p[0] for p in self.shortest_path]
            path_y = [p[1] for p in self.shortest_path]
            ax.plot(path_x, path_y, 'g-', linewidth=3, alpha=0.8, label='Optimal Path (8-dir)')
            
            # Ê†áËÆ∞ÂØπËßíÁ∫øÊÆµ
            for i in range(len(self.shortest_path) - 1):
                p1 = self.shortest_path[i]
                p2 = self.shortest_path[i + 1]
                dx = abs(p2[0] - p1[0])
                dy = abs(p2[1] - p1[1])
                if dx > 0.01 and dy > 0.01:  # ÂØπËßíÁ∫øÁßªÂä®
                    ax.plot([p1[0], p2[0]], [p1[1], p2[1]], 'g--', 
                           linewidth=2, alpha=0.5, zorder=3)
            
            # Ê†áËÆ∞Ëµ∑ÁÇπÂíåÁªàÁÇπ
            ax.plot(path_x[0], path_y[0], 'go', markersize=10, markeredgewidth=2, 
                   markeredgecolor='darkgreen')
            ax.plot(path_x[-1], path_y[-1], 'gs', markersize=10, markeredgewidth=2, 
                   markeredgecolor='darkgreen')
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫‰ΩçÁΩÆ
        ax.plot(self.robot.position[0], self.robot.position[1], 'bo', markersize=8)
        
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.set_title("SLAM Map", fontsize=12)
    
    def draw_radar_simulation(self):
        """ÁªòÂà∂Èõ∑ËææÊ®°ÊãüÂõæ"""
        ax = self.ax_radar
        ax.clear()
        
        # ÊâÄÊúâÊâ©Â±ïÂå∫ÂüüÈÉΩ‰∏çÁªòÂà∂ËÉåÊôØÔºåËÆ©ÂÖ∂‰øùÊåÅ‰∏éÊú™Êâ´ÊèèÂå∫ÂüüÁõ∏ÂêåÁöÑÈ¢úËâ≤
        
        # ÁªòÂà∂Ëø∑ÂÆ´Â¢ôÂ£Å
        for wall in self.maze_env.walls:
            (x1, y1), (x2, y2) = wall
            ax.plot([x1, x2], [y1, y2], 'k-', linewidth=2)
        
        # ÁªòÂà∂Êú∫Âô®‰∫∫‰ΩçÁΩÆ
        robot_x, robot_y = self.robot.position
        ax.plot(robot_x, robot_y, 'bo', markersize=10, label='Robot')
        
        # ÁªòÂà∂Èõ∑ËææÂ∞ÑÁ∫ø
        if self.latest_scan_ranges and self.latest_scan_angles:
            for i, (distance, angle_deg) in enumerate(zip(self.latest_scan_ranges, self.latest_scan_angles)):
                # ËÆ°ÁÆóÂ∞ÑÁ∫øÁªàÁÇπ
                angle_rad = math.radians(angle_deg)
                end_x = robot_x + distance * math.cos(angle_rad)
                end_y = robot_y + distance * math.sin(angle_rad)
                
                # ÁªòÂà∂Â∞ÑÁ∫øÔºà‰ªéÊú∫Âô®‰∫∫Âà∞ÂëΩ‰∏≠ÁÇπÔºâ
                ax.plot([robot_x, end_x], [robot_y, end_y], 'r-', alpha=0.3, linewidth=0.5)
        
        # ÁªòÂà∂Ëá™Áî±Á©∫Èó¥ÁÇπÔºàÊâ´ÊèèÂà∞ÁöÑÁÇπÔºâ
        if self.latest_scan_points:
            scan_x = [p[0] for p in self.latest_scan_points]
            scan_y = [p[1] for p in self.latest_scan_points]
            ax.plot(scan_x, scan_y, 'g.', markersize=1, alpha=0.5, label='Free Space')
        
        # ÁªòÂà∂ÈöúÁ¢çÁÇπ
        if self.latest_obstacle_points:
            obs_x = [p[0] for p in self.latest_obstacle_points]
            obs_y = [p[1] for p in self.latest_obstacle_points]
            ax.plot(obs_x, obs_y, 'ro', markersize=3, alpha=0.8, label='Obstacles')
         
        ax.set_xlim(-2, self.maze_env.size + 2)
        ax.set_ylim(-2, self.maze_env.size + 2)
        ax.set_aspect('equal')
        ax.legend()
        ax.set_title("Radar Simulation", fontsize=12)
    
    def _calculate_coverage(self):
        """ËÆ°ÁÆóÊé¢Á¥¢Ë¶ÜÁõñÁéá"""
        total_cells = self.global_mapper.grid_size * self.global_mapper.grid_size
        explored_cells = len(self.global_mapper.all_explored_cells)
        return (explored_cells / total_cells) * 100

class SmartMazeExplorer:
    """Êô∫ËÉΩËø∑ÂÆ´Êé¢Á¥¢Âô® - ÂâçÊ≤øÊé¢Á¥¢ÁÆóÊ≥ï"""
    
    def __init__(self, robot_id, maze_env, global_mapper, laser_sim, path_planner):
        self.robot_id = robot_id
        self.maze_env = maze_env
        self.global_mapper = global_mapper
        self.laser_sim = laser_sim
        self.path_planner = path_planner
        
        # Êú∫Âô®‰∫∫Áä∂ÊÄÅ
        self.position = self.maze_env.start_pos
        self.steps = 0
        self.max_steps = float('inf')  # ÂèñÊ∂àÊ≠•Êï∞‰∏äÈôêÔºåÁõ¥Âà∞ÂèëÁé∞Âá∫Âè£ÊàñÂ§ñÈÉ®Êù°‰ª∂ÁªàÊ≠¢
        self.status = "Exploring"
        
        # Êé¢Á¥¢ÁõÆÊ†á
        self.current_target = None
        self.target_path = []
        self.path_index = 0
        
        # ÁßªÂä®Ê≠•ÈïøÔºàÊõ¥Â∞è‰ª•Á°Æ‰øùÂπ≥ÊªëÁßªÂä®Ôºâ
        self.step_size = 0.1
        
        # Êé¢Á¥¢Á≠ñÁï•ÂèÇÊï∞
        self.exploration_priority = random.random()  # ÈöèÊú∫Êé¢Á¥¢‰ºòÂÖàÁ∫ß
        
        # ÁßªÂä®Áä∂ÊÄÅËøΩË∏™
        self.stuck_counter = 0  # Âç°‰ΩèËÆ°Êï∞Âô®
        self.no_move_counter = 0  # ‰∏çÁßªÂä®ËÆ°Êï∞Âô®
        self.last_position = self.position  # ‰∏ä‰∏ÄÊ¨°‰ΩçÁΩÆ
        
        # Â≠òÂÇ®ÊúÄÊñ∞ÁöÑÊâ´ÊèèÊï∞ÊçÆÔºàÁî®‰∫éÈõ∑ËææÂèØËßÜÂåñÔºâ
        self.latest_scan_points = []
        self.latest_obstacle_points = []
        self.latest_scan_ranges = []
        self.latest_scan_angles = []
        
    def update(self):
        """Êõ¥Êñ∞Êú∫Âô®‰∫∫Áä∂ÊÄÅÔºà‰ºòÂåñÁâàÔºâ"""
        if self.status in ["Exit Found", "Max Steps", "Stopped", "Stuck"]:
            return False
        
        # ‰∏çÂÜçÂõ†Ê≠•Êï∞ËææÂà∞‰∏äÈôêËÄåÁªàÊ≠¢
        
        # ËÆ∞ÂΩïÁßªÂä®Ââç‰ΩçÁΩÆ
        old_position = self.position
        
        # ÊâßË°åÊøÄÂÖâÊâ´Êèè
        scan_points, obstacle_points, scan_ranges, scan_angles, exit_found = self.laser_sim.scan(self.position)
        
        # Â≠òÂÇ®Êâ´ÊèèÊï∞ÊçÆÁî®‰∫éÂèØËßÜÂåñ
        self.latest_scan_points = scan_points
        self.latest_obstacle_points = obstacle_points
        self.latest_scan_ranges = scan_ranges
        self.latest_scan_angles = scan_angles
        
        # Êõ¥Êñ∞ÂÖ®Â±ÄÂú∞Âõæ
        self.global_mapper.update_map(self.robot_id, self.position, scan_points, obstacle_points)
        
        # È´òÈÄüÊ®°ÂºèÔºöÊØè3Ê≠•Êõ¥Êñ∞‰∏ÄÊ¨°ÂâçÊ≤øÁÇπÔºåÊèêÈ´òÈÄüÂ∫¶
        if self.steps % 3 == 0:
            self.global_mapper.update_frontiers()
        
        # Ê£ÄÊü•ÊòØÂê¶ÊâæÂà∞Âá∫Âè£
        if exit_found:
            self.status = "Exit Found"
            print(f"üéØ {self.robot_id} found exit at {self.position}!")
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶Ë∂ÖËøá3ËΩÆ‰∏çÂä®ÔºåÂ¶ÇÊûúÊòØÂàôÂº∫Âà∂ÈöèÊú∫ÁßªÂä®
        if self.no_move_counter >= 3:
            moved = self._force_safe_random_move()
            if moved:
                self.no_move_counter = 0
                self.last_position = self.position
                self.status = "Forced Move"
            else:
                self.no_move_counter += 1
        else:
            # ÈÄâÊã©Êé¢Á¥¢ÁõÆÊ†á
            if not self.current_target or self._reached_target():
                self._select_new_target()
            
            # ÊâßË°åÁßªÂä®
            moved = False
            if self.current_target:
                moved = self._move_towards_target()
            else:
                # Ê≤°ÊúâÁõÆÊ†áÊó∂ÔºåÈöèÊú∫Êé¢Á¥¢
                moved = self._random_exploration()
            
            # Ê£ÄÊü•ÊòØÂê¶ÂÆûÈôÖÁßªÂä®‰∫Ü‰ΩçÁΩÆ
            position_changed = (abs(self.position[0] - self.last_position[0]) > 0.01 or 
                              abs(self.position[1] - self.last_position[1]) > 0.01)
            
            if position_changed:
                self.no_move_counter = 0  # ÈáçÁΩÆ‰∏çÁßªÂä®ËÆ°Êï∞Âô®
                self.last_position = self.position
            else:
                self.no_move_counter += 1  # Â¢ûÂä†‰∏çÁßªÂä®ËÆ°Êï∞Âô®
            
            # Ê£ÄÊü•ÊòØÂê¶ÁßªÂä®ÊàêÂäü
            if not moved:
                self.stuck_counter += 1
                if self.stuck_counter > 10:  # ËøûÁª≠10Ê¨°Êó†Ê≥ïÁßªÂä®
                    self.status = "Stuck"
                    return False
            else:
                self.stuck_counter = 0  # ÈáçÁΩÆÂç°‰ΩèËÆ°Êï∞Âô®
        
        self.steps += 1
        return True
    
    def _select_new_target(self):
        """ÈÄâÊã©Êñ∞ÁöÑÊé¢Á¥¢ÁõÆÊ†á"""
        # Ëé∑ÂèñÊâÄÊúâÊú∫Âô®‰∫∫‰ΩçÁΩÆÔºàÁî®‰∫éÂàÜÈÖçÂâçÊ≤øÁÇπÔºâ
        robot_positions = {}
        for rid, path in self.global_mapper.robot_paths.items():
            if path:
                robot_positions[rid] = path[-1]
        
        # ÂàÜÈÖçÂâçÊ≤øÁõÆÊ†á
        frontier_assignments = self.global_mapper.assign_frontiers_to_robots(robot_positions)
        
        if self.robot_id in frontier_assignments:
            # ÂàÜÈÖçÂà∞ÂâçÊ≤øÁõÆÊ†á
            target = frontier_assignments[self.robot_id]
            self.current_target = target
            self.status = "To Frontier"
            
            # ËßÑÂàíË∑ØÂæÑ
            self.target_path = self.path_planner.plan_path(self.position, target)
            self.path_index = 0

        else:
            # Ê≤°ÊúâÂâçÊ≤øÁÇπÔºåÂ∞ùËØïÊé¢Á¥¢ËæπÁïåÂå∫Âüü
            self._explore_boundary_areas()
    
    def _explore_boundary_areas(self):
        """Êé¢Á¥¢ËæπÁïåÂå∫ÂüüÂØªÊâæÂá∫Âè£"""
        # ‰ºòÂÖàÊé¢Á¥¢Ëø∑ÂÆ´ËæπÁïå
        boundary_targets = []
        
        # ÁîüÊàêËæπÁïåÊé¢Á¥¢ÁÇπ
        for i in range(0, int(self.maze_env.size), 2):
            # ‰∏äËæπÁïå
            boundary_targets.append((i + 0.5, self.maze_env.size - 0.5))
            # ‰∏ãËæπÁïå
            boundary_targets.append((i + 0.5, 0.5))
            # Â∑¶ËæπÁïå
            boundary_targets.append((0.5, i + 0.5))
            # Âè≥ËæπÁïå
            boundary_targets.append((self.maze_env.size - 0.5, i + 0.5))
        
        # ÊâæÂà∞ÊúÄËøëÁöÑÊú™Êé¢Á¥¢ËæπÁïåÁÇπ
        min_dist = float('inf')
        best_target = None
        
        for target in boundary_targets:
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèË¢´Êé¢Á¥¢
            grid_pos = self.global_mapper.world_to_grid(target)
            if self.global_mapper.global_map[grid_pos[1], grid_pos[0]] == 0:  # Êú™Êé¢Á¥¢
                dist = math.sqrt((self.position[0] - target[0])**2 + (self.position[1] - target[1])**2)
                if dist < min_dist:
                    min_dist = dist
                    best_target = target
        
        if best_target:
            self.current_target = best_target
            self.status = "To Boundary"
            self.target_path = self.path_planner.plan_path(self.position, best_target)
            self.path_index = 0
        else:
            # ÊâÄÊúâÂå∫ÂüüÈÉΩÂ∑≤Êé¢Á¥¢
            self.status = "Complete"
            self.current_target = None
    
    def _reached_target(self):
        """Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÁõÆÊ†á"""
        if not self.current_target:
            return True
        
        dist = math.sqrt((self.position[0] - self.current_target[0])**2 + 
                        (self.position[1] - self.current_target[1])**2)
        return dist < 0.5
    
    def _move_towards_target(self):
        """ÂêëÁõÆÊ†áÁßªÂä®ÔºàÂ¢ûÂº∫Á¢∞ÊíûÊ£ÄÊµãÔºâ"""
        if not self.target_path or self.path_index >= len(self.target_path):
            return False
        
        # Ëé∑ÂèñË∑ØÂæÑ‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™ÁÇπ
        next_waypoint = self.target_path[self.path_index]
        
        # ËÆ°ÁÆóÁßªÂä®ÊñπÂêë
        dx = next_waypoint[0] - self.position[0]
        dy = next_waypoint[1] - self.position[1]
        distance = math.sqrt(dx**2 + dy**2)
        
        if distance < self.step_size:
            # Âà∞ËææÂΩìÂâçË∑ØÂæÑÁÇπÔºå‰ΩÜË¶ÅÈ™åËØÅÊòØÂê¶ÂÆâÂÖ®
            if self._is_movement_safe(self.position, next_waypoint):
                self.position = next_waypoint
                self.path_index += 1
                return True
            else:
                # Ë∑ØÂæÑÁÇπ‰∏çÂÆâÂÖ®ÔºåÈáçÊñ∞ËßÑÂàí
                self._replan_path()
                return False
        else:
            # ÂêëÂΩìÂâçË∑ØÂæÑÁÇπÁßªÂä®
            move_x = self.position[0] + (dx / distance) * self.step_size
            move_y = self.position[1] + (dy / distance) * self.step_size
            new_position = (move_x, move_y)
            
            # ‰∏•Ê†ºÊ£ÄÊü•ÁßªÂä®ÂÆâÂÖ®ÊÄß
            if self._is_movement_safe(self.position, new_position):
                self.position = new_position
                return True
            else:
                # Ë∑ØÂæÑË¢´ÈòªÊå°ÔºåÂ∞ùËØïÁªïË°åÊàñÈáçÊñ∞ËßÑÂàí
                if self._try_avoid_obstacle():
                    return True
                else:
                    self._replan_path()
                    return False
    
    def _is_movement_safe(self, from_pos, to_pos):
        """Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÂÆâÂÖ®ÔºàÂ§öÈáçÈ™åËØÅÔºåÈôêÂà∂Âú®0Âà∞sizeÂå∫ÂüüÔºâ"""
        # Âü∫Á°ÄÁ¢∞ÊíûÊ£ÄÊµã
        if not self.maze_env.can_move_to(from_pos, to_pos):
            return False
        
        # ËæπÁïåÊ£ÄÊü•Âà∞ÊúâÊïàÁßªÂä®Âå∫ÂüüÔºàÂÖÅËÆ∏Êâ©Â±ïÂå∫Âüü -2 Âà∞ size+2Ôºå‰øùÁïôÂ∞èÁöÑÂÆâÂÖ®ËæπË∑ùÔºâ
        margin = 0.05
        extended_margin = 2.0 - margin
        if not (-extended_margin <= to_pos[0] <= self.maze_env.size + extended_margin and 
                -extended_margin <= to_pos[1] <= self.maze_env.size + extended_margin):
            return False
        
        # Â¢ôÂ£ÅË∑ùÁ¶ªÊ£ÄÊü•
        safety_distance = 0.15
        for wall in self.maze_env.walls + self.maze_env.invisible_walls:
            if self._point_to_line_distance(to_pos, wall[0], wall[1]) < safety_distance:
                return False
        
        return True
    
    def _point_to_line_distance(self, point, line_start, line_end):
        """ËÆ°ÁÆóÁÇπÂà∞Á∫øÊÆµÁöÑË∑ùÁ¶ª"""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        # Á∫øÊÆµÈïøÂ∫¶
        line_len = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        if line_len == 0:
            return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)
        
        # ËÆ°ÁÆóÊäïÂΩ±ÂèÇÊï∞
        t = max(0, min(1, ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / (line_len**2)))
        
        # ÊäïÂΩ±ÁÇπ
        proj_x = x1 + t * (x2 - x1)
        proj_y = y1 + t * (y2 - y1)
        
        # Ë∑ùÁ¶ª
        return math.sqrt((x0 - proj_x)**2 + (y0 - proj_y)**2)
    
    def _try_avoid_obstacle(self):
        """Â∞ùËØïÈÅøÂºÄÈöúÁ¢çÁâ©"""
        # Â∞ùËØïÂ∑¶Âè≥ÁªïË°å
        angles = [math.pi/4, -math.pi/4, math.pi/2, -math.pi/2]  # 45Â∫¶„ÄÅ90Â∫¶Â∑¶Âè≥
        
        for angle in angles:
            # ËÆ°ÁÆóÁªïË°åÊñπÂêë
            cos_a, sin_a = math.cos(angle), math.sin(angle)
            new_x = self.position[0] + self.step_size * cos_a
            new_y = self.position[1] + self.step_size * sin_a
            new_pos = (new_x, new_y)
            
            if self._is_movement_safe(self.position, new_pos):
                self.position = new_pos
                return True
        
        return False
    
    def _replan_path(self):
        """ÈáçÊñ∞ËßÑÂàíË∑ØÂæÑ"""
        if self.current_target:
            self.target_path = self.path_planner.plan_path(self.position, self.current_target)
            self.path_index = 0
            
            # Â¶ÇÊûúÈáçÊñ∞ËßÑÂàíÂêéË∑ØÂæÑÂ§™Áü≠ÔºåËØ¥ÊòéÁõÆÊ†á‰∏çÂèØËææ
            if len(self.target_path) <= 1:
                self.current_target = None
                self.status = "Target Unreachable"
    
    def _random_exploration(self):
        """ÈöèÊú∫Êé¢Á¥¢ÔºàÂΩìÊ≤°ÊúâÁõÆÊ†áÊó∂ÔºâÔºàÂ¢ûÂº∫ÂÆâÂÖ®ÊÄßÔºâ"""
        # Â∞ùËØïÂ§ö‰∏™ÈöèÊú∫ÊñπÂêë
        max_attempts = 8
        
        for _ in range(max_attempts):
            # ÈöèÊú∫ÈÄâÊã©ÊñπÂêë
            angle = random.uniform(0, 2 * math.pi)
            move_x = self.position[0] + self.step_size * math.cos(angle)
            move_y = self.position[1] + self.step_size * math.sin(angle)
            new_position = (move_x, move_y)
            
            # ‰ΩøÁî®Â¢ûÂº∫ÁöÑÂÆâÂÖ®Ê£ÄÊü•
            if self._is_movement_safe(self.position, new_position):
                self.position = new_position
                self.status = "Random"
                return True
        
        # Â¶ÇÊûúÊâÄÊúâÈöèÊú∫ÊñπÂêëÈÉΩË¢´ÈòªÊå°ÔºåÂ∞ùËØïÂõ∫ÂÆöÊñπÂêë
        fixed_directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        for dx, dy in fixed_directions:
            move_x = self.position[0] + self.step_size * dx
            move_y = self.position[1] + self.step_size * dy
            new_position = (move_x, move_y)
            
            if self._is_movement_safe(self.position, new_position):
                self.position = new_position
                self.status = "Random"
                return True
        
        # Â¶ÇÊûúÂÆåÂÖ®Êó†Ê≥ïÁßªÂä®Ôºå‰øùÊåÅÂéü‰Ωç
        self.status = "No Move"
        return False
    
    def _force_safe_random_move(self):
        """Âº∫Âà∂ÂÆâÂÖ®ÈöèÊú∫ÁßªÂä®ÔºàÂΩìÂ∞èËΩ¶Ë∂ÖËøá2ËΩÆ‰∏çÂä®Êó∂Ôºâ"""
        print(f"üö® Forcing safe random move for {self.robot_id}...")
        
        # Â∞ùËØïÊõ¥Â§öÊñπÂêëÂíåÊõ¥Â∞èÁöÑÊ≠•Èïø
        step_sizes = [self.step_size, self.step_size * 0.7, self.step_size * 0.5]  # Â∞ùËØï‰∏çÂêåÊ≠•Èïø
        
        for step_size in step_sizes:
            # Â∞ùËØï12‰∏™ÊñπÂêëÔºàÊØè30Â∫¶‰∏Ä‰∏™Ôºâ
            for angle_deg in range(0, 360, 30):
                angle_rad = math.radians(angle_deg)
                move_x = self.position[0] + step_size * math.cos(angle_rad)
                move_y = self.position[1] + step_size * math.sin(angle_rad)
                new_position = (move_x, move_y)
                
                # ‰ΩøÁî®Â¢ûÂº∫ÁöÑÂÆâÂÖ®Ê£ÄÊü•
                if self._is_movement_safe(self.position, new_position):
                    print(f"‚úÖ Found safe direction: {angle_deg}¬∞ with step size {step_size:.2f}")
                    self.position = new_position
                    self.status = "Forced Random"
                    return True
            
            # Â¶ÇÊûú12‰∏™ÊñπÂêëÈÉΩ‰∏çË°åÔºåÂ∞ùËØïÊõ¥Á≤æÁªÜÁöÑÊñπÂêë
            for angle_deg in range(15, 360, 15):  # ÊØè15Â∫¶‰∏Ä‰∏™
                angle_rad = math.radians(angle_deg)
                move_x = self.position[0] + step_size * math.cos(angle_rad)
                move_y = self.position[1] + step_size * math.sin(angle_rad)
                new_position = (move_x, move_y)
                
                if self._is_movement_safe(self.position, new_position):
                    print(f"‚úÖ Found safe direction: {angle_deg}¬∞ with step size {step_size:.2f}")
                    self.position = new_position
                    self.status = "Forced Random"
                    return True
        
        # Â¶ÇÊûúÊâÄÊúâÊñπÂêëÈÉΩË¢´ÈòªÊå°ÔºåÂ∞ùËØïÈùûÂ∏∏Â∞èÁöÑÁßªÂä®
        tiny_step = self.step_size * 0.2
        tiny_directions = [(1, 0), (-1, 0), (0, 1), (0, -1), 
                          (0.7, 0.7), (-0.7, 0.7), (0.7, -0.7), (-0.7, -0.7)]
        
        for dx, dy in tiny_directions:
            # Ê†áÂáÜÂåñÊñπÂêëÂêëÈáè
            length = math.sqrt(dx*dx + dy*dy)
            dx, dy = dx/length, dy/length
            
            move_x = self.position[0] + tiny_step * dx
            move_y = self.position[1] + tiny_step * dy
            new_position = (move_x, move_y)
            
            if self._is_movement_safe(self.position, new_position):
                print(f"‚úÖ Found tiny safe move: ({dx:.2f}, {dy:.2f}) with step size {tiny_step:.2f}")
                self.position = new_position
                self.status = "Forced Tiny"
                return True
        
        print(f"‚ùå Cannot find any safe random move for {self.robot_id}")
        return False

class GlobalMazeSLAMSystem:
    """ÂçïÊú∫Âô®‰∫∫Ëø∑ÂÆ´SLAMÁ≥ªÁªü‰∏ªÊéßÂà∂Âô®"""
    
    def __init__(self, map_file="BreezySLAM-master/examples/map1.json"):

        # ÂàùÂßãÂåñÁéØÂ¢ÉÂíåÁªÑ‰ª∂
        self.maze_env = MazeEnvironment(map_file)
        self.global_mapper = GlobalSLAMMapper(self.maze_env.size, self.maze_env.display_size)
        self.global_mapper.set_maze_env(self.maze_env)  # ËÆæÁΩÆËø∑ÂÆ´ÁéØÂ¢ÉÂºïÁî®
        self.path_planner = AStarPathPlanner(self.global_mapper, self.maze_env)
        
        # ÂàõÂª∫Âçï‰∏™Êú∫Âô®‰∫∫
        robot_id = "Robot-1"
        laser_sim = LaserSimulator(self.maze_env)
        
        self.robot = SmartMazeExplorer(robot_id, self.maze_env, self.global_mapper, laser_sim, self.path_planner)
        self.robot.position = self.maze_env.start_pos
        self.robot.step_size = 0.15  # È´òÈÄüÊ®°ÂºèÔºöÂ¢ûÂ§ßÊ≠•ÈïøÔºåÊèêÈ´òÁßªÂä®ÈÄüÂ∫¶
        
        # ÂàõÂª∫ÂèØËßÜÂåñÂô®
        self.visualizer = SingleRobotVisualizer(self.maze_env, self.global_mapper, self.robot)
        
        # ÊúÄÁü≠Ë∑ØÂæÑÁõ∏ÂÖ≥
        self.shortest_path = None
        self.exploration_completed = False

    def run_exploration(self):
        import time
        start_time = time.time()
        target_time = 300  # 5ÂàÜÈíü = 300Áßí
        
        iteration = 0  # ÁªüËÆ°Â∑≤ÊâßË°åËø≠‰ª£Ê¨°Êï∞Ôºà‰∏çÂÜçËÆæÂõ∫ÂÆö‰∏äÈôêÔºâ
        
        while True:  # ‰ªÖÂèóÊó∂Èó¥ÈôêÂà∂ÊàñÈÄÄÂá∫Êù°‰ª∂ÊéßÂà∂
            iteration += 1
            
            # Êõ¥Êñ∞Êú∫Âô®‰∫∫
            robot_active = self.robot.update()
            
            # Ê£ÄÊü•Êó∂Èó¥ÈôêÂà∂Ôºà5ÂàÜÈíüÔºâ
            elapsed_time = time.time() - start_time
            if elapsed_time > target_time:
                print(f"‚è∞ Time limit reached: {elapsed_time:.1f}s")
                break
            
            # Ê£ÄÊü•ÁªàÊ≠¢Êù°‰ª∂
            if self._check_termination_conditions(robot_active):
                break
            
            # Êõ¥Êñ∞ÂèØËßÜÂåñÔºàÈ´òÈÄüÊ®°ÂºèÔºöÊØè5Ê¨°Ëø≠‰ª£Êõ¥Êñ∞‰∏ÄÊ¨°Ôºâ
            if iteration % 5 == 0:
                self._update_visualization()
            
            # ËøõÂ∫¶Êä•ÂëäÔºàÈ´òÈÄüÊ®°ÂºèÔºöÊØè50Ê¨°Êä•Âëä‰∏ÄÊ¨°Ôºâ
            if iteration % 50 == 0:
                frontiers_count = len(self.global_mapper.frontiers)
                coverage = self._calculate_coverage()
                current_time = time.time() - start_time
                iterations_per_sec = iteration / current_time if current_time > 0 else 0
                estimated_total = iterations_per_sec * target_time if iterations_per_sec > 0 else 0
                print(f"‚è±Ô∏è  Step {iteration}: {current_time:.1f}s, "
                      f"{iterations_per_sec:.1f} iter/s, Est.Total(5m): {estimated_total:.0f}, "
                      f"Robot: ({self.robot.position[0]:.2f}, {self.robot.position[1]:.2f}), "
                      f"Status: {self.robot.status}, Coverage: {coverage:.1f}%")
        
        # ÊÄßËÉΩÁªüËÆ°
        total_time = time.time() - start_time
        avg_speed = iteration / total_time if total_time > 0 else 0

        # Á°Æ‰øùÊúÄÁü≠Ë∑ØÂæÑË¢´‰º†ÈÄíÁªôÂèØËßÜÂåñÂô®
        if self.exploration_completed and self.shortest_path:
            self.visualizer.set_shortest_path(self.shortest_path)
        
        # Âà∑Êñ∞‰∏ÄÊ¨°ÂèØËßÜÂåñÔºåÁ°Æ‰øùÁªàÁÇπÁ∫¢ÂúàÂíåÊúÄÁü≠Ë∑ØÂæÑÊòæÁ§∫
        self._update_visualization()
        
        self._print_final_results()
        
        # ‰øùÊåÅÊòæÁ§∫
        plt.ioff()
        plt.show()
    
    def _check_termination_conditions(self, robot_active):
        """Ê£ÄÊü•ÁªàÊ≠¢Êù°‰ª∂"""
        # Êñ∞ÁöÑÁªàÊ≠¢Êù°‰ª∂ÔºöÂèëÁé∞Âá∫Âè£ AND ÊâÄÊúâ0-maxÂå∫ÂüüÁöÑÂâçÊ≤øÁÇπÈÉΩÂ∑≤ÈÅçÂéÜ
        if self.maze_env.exit_detected:
            # Ê£ÄÊü•ÊòØÂê¶ËøòÊúâ0-maxÂå∫ÂüüÂÜÖÁöÑÂâçÊ≤øÁÇπÊú™ÈÅçÂéÜ
            remaining_core_frontiers = 0
            for frontier in self.global_mapper.frontiers:
                if (0 <= frontier[0] <= self.maze_env.size and 
                    0 <= frontier[1] <= self.maze_env.size):
                    remaining_core_frontiers += 1
            
            if remaining_core_frontiers > 0:
                print(f"üéØ Exit found, but {remaining_core_frontiers} core frontiers remain. Continuing exploration...")
                return False
            
            if self.maze_env.exit_position and len(self.maze_env.reached_exit_positions) == 0:
                self.maze_env.mark_exit_reached(self.maze_env.exit_position)
            print("üéØ Exit found and all core frontiers explored! Exploration complete.")
            
            # ËÆ°ÁÆóÊúÄÁü≠Ë∑ØÂæÑ
            self._calculate_shortest_path()
            self.exploration_completed = True
            return True
        
        # Ëã•Êú∫Âô®‰∫∫Áâ©ÁêÜ‰ΩçÁΩÆÂ∑≤ÁªèË∂äËøá‰∏ªËø∑ÂÆ´ËæπÁïåÔºàÂê´Êâ©Â±ïÂå∫ÔºâÔºåÂêåÊ†∑ËßÜ‰∏∫ÊàêÂäüÈÄÉÂá∫
        robot_pos = self.robot.position
        if robot_pos[0] < -1.9 or robot_pos[0] > self.maze_env.size + 1.9 or \
           robot_pos[1] < -1.9 or robot_pos[1] > self.maze_env.size + 1.9:
            # Âú®ÊûÅÁ´ØË∂äÁïå‰ΩçÁΩÆÁõ¥Êé•Ê†áËÆ∞Âá∫Âè£
            self.maze_env.mark_exit_reached(robot_pos)
            print("üéâ Robot physically left maze boundary ‚Äî exit assumed.")
            
            # ËÆ°ÁÆóÊúÄÁü≠Ë∑ØÂæÑ
            self._calculate_shortest_path()
            self.exploration_completed = True
            return True
        
        return False
    
    def _calculate_coverage(self):
        """ËÆ°ÁÆóÊé¢Á¥¢Ë¶ÜÁõñÁéá"""
        total_cells = self.global_mapper.grid_size * self.global_mapper.grid_size
        explored_cells = len(self.global_mapper.all_explored_cells)
        return (explored_cells / total_cells) * 100
    
    def _calculate_shortest_path(self):
        """ËÆ°ÁÆó‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÊúÄÁü≠Ë∑ØÂæÑÔºà‰ΩøÁî®ÂÖ´ÊñπÂêëA*ÁÆóÊ≥ïÔºâ"""
        print("üõ§Ô∏è  Calculating optimal shortest path from start to end...")
        
        # Ëé∑ÂèñËµ∑ÁÇπÂíåÁªàÁÇπ
        start_pos = self.maze_env.start_pos
        
        # Á°ÆÂÆöÁªàÁÇπÔºö‰ºòÂÖà‰ΩøÁî®Â∑≤Âà∞ËææÁöÑÂá∫Âè£‰ΩçÁΩÆÔºåÂê¶Âàô‰ΩøÁî®È¢ÑËÆæÂá∫Âè£
        if self.maze_env.reached_exit_positions:
            end_pos = self.maze_env.reached_exit_positions[0]  # ‰ΩøÁî®Á¨¨‰∏Ä‰∏™Âà∞ËææÁöÑÂá∫Âè£
        elif self.maze_env.discovered_exits:
            end_pos = self.maze_env.discovered_exits[0]  # ‰ΩøÁî®Á¨¨‰∏Ä‰∏™ÂèëÁé∞ÁöÑÂá∫Âè£
        elif self.maze_env.exits:
            end_pos = self.maze_env.exits[0]  # ‰ΩøÁî®È¢ÑËÆæÂá∫Âè£
        else:
            print("‚ùå No exit found, cannot calculate shortest path")
            return
        
        # ÂàõÂª∫‰∏ìÁî®‰∫éÊúÄÁü≠Ë∑ØÂæÑËÆ°ÁÆóÁöÑÂÖ´ÊñπÂêëA*ËßÑÂàíÂô®
        optimal_planner = OptimalPathPlanner(self.global_mapper, self.maze_env)
        
        # ‰ΩøÁî®ÂÖ´ÊñπÂêëA*ÁÆóÊ≥ïËÆ°ÁÆóÊúÄ‰ºòË∑ØÂæÑ
        self.shortest_path = optimal_planner.plan_optimal_path(start_pos, end_pos)
        
        if self.shortest_path and len(self.shortest_path) > 1:
            # ËÆ°ÁÆóË∑ØÂæÑÈïøÂ∫¶ÔºàÁ≤æÁ°ÆËÆ°ÁÆóÔºåÂåÖÊã¨ÂØπËßíÁ∫øË∑ùÁ¶ªÔºâ
            path_length = 0
            diagonal_segments = 0
            straight_segments = 0
            
            for i in range(len(self.shortest_path) - 1):
                p1 = self.shortest_path[i]
                p2 = self.shortest_path[i + 1]
                segment_length = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                path_length += segment_length
                
                # ÁªüËÆ°Áõ¥Á∫øÂíåÂØπËßíÁ∫øÊÆµÊï∞
                dx = abs(p2[0] - p1[0])
                dy = abs(p2[1] - p1[1])
                if dx > 0.01 and dy > 0.01:
                    diagonal_segments += 1
                else:
                    straight_segments += 1
            
        else:
            print("‚ùå Failed to calculate optimal shortest path")
    
    def _update_visualization(self):
        """Êõ¥Êñ∞ÂèØËßÜÂåñ"""
        # Êõ¥Êñ∞Êâ´ÊèèÊï∞ÊçÆ
        self.visualizer.update_scan_data(
            self.robot.latest_scan_points,
            self.robot.latest_obstacle_points,
            self.robot.latest_scan_ranges,
            self.robot.latest_scan_angles
        )
        
        # Â¶ÇÊûúÊé¢Á¥¢ÂÆåÊàêÔºå‰º†ÈÄíÊúÄÁü≠Ë∑ØÂæÑ
        if self.exploration_completed and self.shortest_path:
            self.visualizer.set_shortest_path(self.shortest_path)
        
        # Êõ¥Êñ∞ÊòæÁ§∫
        self.visualizer.update_display()
    
    def _print_final_results(self):

        # ÊòæÁ§∫Âà∞Â∑≤ÂèëÁé∞Âá∫Âè£ÁöÑË∑ùÁ¶ª
        if self.maze_env.discovered_exits:
            print(f"   Distances to discovered exits:")
            for i, exit_pos in enumerate(self.maze_env.discovered_exits):
                distance = math.sqrt((self.robot.position[0] - exit_pos[0])**2 +
                                   (self.robot.position[1] - exit_pos[1])**2)
                print(f"     Discovered Exit{i+1} at ({exit_pos[0]:.1f}, {exit_pos[1]:.1f}): {distance:.2f} units")
        else:
            print(f"   No exits discovered yet")


        if self.maze_env.exit_detected:
            print(f"   Exit detection position: {self.maze_env.exit_position}")

        # ÊòæÁ§∫ËæπÁïåË∑ùÁ¶ª
        robot_pos = self.robot.position
        distance_to_boundary = min(
            robot_pos[0],  # Ë∑ùÂ∑¶ËæπÁïå
            robot_pos[1],  # Ë∑ù‰∏ãËæπÁïå
            self.maze_env.size - robot_pos[0],  # Ë∑ùÂè≥ËæπÁïå
            self.maze_env.size - robot_pos[1]   # Ë∑ù‰∏äËæπÁïå
        )
        print(f"   Distance to boundary: {distance_to_boundary:.2f} units")
        
        # ÊòæÁ§∫ÊúÄÁü≠Ë∑ØÂæÑ‰ø°ÊÅØ
        if self.shortest_path and len(self.shortest_path) > 1:
            path_length = 0
            diagonal_segments = 0
            straight_segments = 0
            
            for i in range(len(self.shortest_path) - 1):
                p1 = self.shortest_path[i]
                p2 = self.shortest_path[i + 1]
                segment_length = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                path_length += segment_length
                
                # ÁªüËÆ°Áõ¥Á∫øÂíåÂØπËßíÁ∫øÊÆµÊï∞
                dx = abs(p2[0] - p1[0])
                dy = abs(p2[1] - p1[1])
                if dx > 0.01 and dy > 0.01:
                    diagonal_segments += 1
                else:
                    straight_segments += 1
            
            print(f"\nüõ§Ô∏è  Optimal Path Information (8-Direction A*):")
            print(f"   üìç Start: ({self.maze_env.start_pos[0]:.2f}, {self.maze_env.start_pos[1]:.2f})")
            if self.maze_env.reached_exit_positions:
                end_pos = self.maze_env.reached_exit_positions[0]
            elif self.maze_env.discovered_exits:
                end_pos = self.maze_env.discovered_exits[0]
            elif self.maze_env.exits:
                end_pos = self.maze_env.exits[0]
            else:
                end_pos = None
            
        print("="*60)

def main():
    """‰∏ªÁ®ãÂ∫è"""
    print("üîç Single Robot Maze SLAM Explorer - High Speed Mode")
    print("="*56)
    
    # ÂèØ‰ª•Êõ¥ÊîπÂú∞ÂõæÊñá‰ª∂
    map_file = "BreezySLAM-master/examples/map1.json"
    
    try:
        # ÂàõÂª∫Âπ∂ËøêË°åÂçïÊú∫Âô®‰∫∫Á≥ªÁªü
        system = GlobalMazeSLAMSystem(map_file)
        system.run_exploration()
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Exploration interrupted by user")
    except Exception as e:
        print(f"‚ùå Error during exploration: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main() 